   1               		.file	"bootloader.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
 115               		.section	.text.bl_uart_getc,"ax",@progbits
 117               	.global	bl_uart_getc
 119               	bl_uart_getc:
 120               		.stabd	46,0,0
   0:bootloader.c  **** #include "app.h"
   1:bootloader.c  **** #include "common.h"
   2:bootloader.c  **** 
   3:bootloader.c  **** #include <inttypes.h>
   4:bootloader.c  **** #include <avr/io.h>
   5:bootloader.c  **** #include <avr/interrupt.h>
   6:bootloader.c  **** #include <avr/wdt.h>
   7:bootloader.c  **** #include <avr/boot.h>
   8:bootloader.c  **** #include <avr/pgmspace.h>
   9:bootloader.c  **** #include <util/delay.h>
  10:bootloader.c  **** #include <avr/eeprom.h>
  11:bootloader.c  **** 
  12:bootloader.c  **** #include "uart.h"
  13:bootloader.c  **** #include "midi.h"
  14:bootloader.c  **** #include "sr165.h"
  15:bootloader.c  **** #include "lcd.h"
  16:bootloader.c  **** 
  17:bootloader.c  **** int main(void);
  18:bootloader.c  **** 
  19:bootloader.c  **** #define ROM_SIZE 32768
  20:bootloader.c  **** 
  21:bootloader.c  **** #define _B2048
  22:bootloader.c  **** 
  23:bootloader.c  **** #ifdef _B128
  24:bootloader.c  ****   #define APP_PAGES ((2*ROM_SIZE / SPM_PAGESIZE)- (2*128 / SPM_PAGESIZE )) 
  25:bootloader.c  ****   #define APP_END APP_PAGES * SPM_PAGESIZE 
  26:bootloader.c  **** #endif
  27:bootloader.c  **** #ifdef _B256
  28:bootloader.c  ****   #define APP_PAGES ((2*ROM_SIZE / SPM_PAGESIZE)- (2*256 / SPM_PAGESIZE )) 
  29:bootloader.c  ****   #define APP_END APP_PAGES * SPM_PAGESIZE 
  30:bootloader.c  **** #endif
  31:bootloader.c  **** #ifdef _B512
  32:bootloader.c  ****   #define APP_PAGES ((2*ROM_SIZE / SPM_PAGESIZE)- (2*512 / SPM_PAGESIZE )) 
  33:bootloader.c  ****   #define APP_END APP_PAGES * SPM_PAGESIZE 
  34:bootloader.c  **** #endif
  35:bootloader.c  **** #ifdef _B1024
  36:bootloader.c  ****   #define APP_PAGES ((2*ROM_SIZE / SPM_PAGESIZE)- (2*1024 / SPM_PAGESIZE )) 
  37:bootloader.c  ****   #define APP_END APP_PAGES * SPM_PAGESIZE 
  38:bootloader.c  **** #endif  
  39:bootloader.c  **** #ifdef _B2048
  40:bootloader.c  ****   #define APP_PAGES ((2*ROM_SIZE / SPM_PAGESIZE)- (2*2048 / SPM_PAGESIZE )) 
  41:bootloader.c  ****   #define APP_END APP_PAGES * SPM_PAGESIZE 
  42:bootloader.c  **** #endif   
  43:bootloader.c  **** 
  44:bootloader.c  **** void (*jump_to_app)(void) = 0x0000;
  45:bootloader.c  **** static uint16_t sysex_address = 0;
  46:bootloader.c  **** static uint16_t recvd = 0;
  47:bootloader.c  **** 
  48:bootloader.c  **** void write_block_data(void);
  49:bootloader.c  **** 
  50:bootloader.c  **** uint8_t check_firmware_checksum(void) {
  51:bootloader.c  ****   uint16_t len = eeprom_read_word(FIRMWARE_LENGTH_ADDR);
  52:bootloader.c  ****   uint16_t firm_checksum = eeprom_read_word(FIRMWARE_CHECKSUM_ADDR);
  53:bootloader.c  ****   uint16_t i;
  54:bootloader.c  ****   uint16_t checksum = 0;
  55:bootloader.c  ****   
  56:bootloader.c  ****   for (i = 0; i < len; i++) {
  57:bootloader.c  ****     checksum += pgm_read_byte(i);
  58:bootloader.c  ****   }
  59:bootloader.c  **** 
  60:bootloader.c  ****   if ((checksum & 0x3FFF) == firm_checksum)
  61:bootloader.c  ****     return 1;
  62:bootloader.c  ****   else
  63:bootloader.c  ****     return 0;
  64:bootloader.c  **** }
  65:bootloader.c  **** 
  66:bootloader.c  **** void write_firmware_checksum(uint16_t len, uint16_t checksum) {
  67:bootloader.c  ****   eeprom_write_word(FIRMWARE_LENGTH_ADDR, len);
  68:bootloader.c  ****   eeprom_write_word(FIRMWARE_CHECKSUM_ADDR, checksum);
  69:bootloader.c  ****   eeprom_write_word(START_MAIN_APP_ADDR, 1);
  70:bootloader.c  **** }
  71:bootloader.c  **** 
  72:bootloader.c  **** uint8_t bl_uart_getc(void) {
 122               	.LM0:
 123               	.LFBB1:
 124               	/* prologue: function */
 125               	/* frame size = 0 */
 126               	.L2:
  73:bootloader.c  ****   while (!UART_CHECK_RX())
 128               	.LM1:
 129 0000 5F9B      		sbis 43-32,7
 130 0002 00C0      		rjmp .L2
  74:bootloader.c  ****     ;
  75:bootloader.c  ****   return UART_READ_CHAR();
 132               	.LM2:
 133 0004 8CB1      		in r24,44-32
 134               	/* epilogue start */
  76:bootloader.c  **** }
 136               	.LM3:
 137 0006 0895      		ret
 139               	.Lscope1:
 141               		.stabd	78,0,0
 142               		.section	.text.bl_uart_putc,"ax",@progbits
 145               	.global	bl_uart_putc
 147               	bl_uart_putc:
 148               		.stabd	46,0,0
  77:bootloader.c  **** 
  78:bootloader.c  **** void bl_uart_putc(uint8_t c) {
 150               	.LM4:
 151               	.LFBB2:
 152               	/* prologue: function */
 153               	/* frame size = 0 */
 154               	.L6:
  79:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 156               	.LM5:
 157 0000 5D9B      		sbis 43-32,5
 158 0002 00C0      		rjmp .L6
  80:bootloader.c  ****     ;
  81:bootloader.c  ****   UART_WRITE_CHAR(c);
 160               	.LM6:
 161 0004 8CB9      		out 44-32,r24
 162               	/* epilogue start */
  82:bootloader.c  **** }
 164               	.LM7:
 165 0006 0895      		ret
 167               	.Lscope2:
 169               		.stabd	78,0,0
 170               		.section	.text.midi_sysex_send_ack,"ax",@progbits
 172               	.global	midi_sysex_send_ack
 174               	midi_sysex_send_ack:
 175               		.stabd	46,0,0
  83:bootloader.c  **** 
  84:bootloader.c  **** uint8_t ack_msg[6] = {
  85:bootloader.c  ****   0xf0, SYSEX_VENDOR_1, SYSEX_VENDOR_2, SYSEX_VENDOR_3, CMD_DATA_BLOCK_ACK, 0xf7
  86:bootloader.c  **** };
  87:bootloader.c  **** 
  88:bootloader.c  **** uint8_t nak_msg[6] = {
  89:bootloader.c  ****   0xf0, SYSEX_VENDOR_1, SYSEX_VENDOR_2, SYSEX_VENDOR_3, CMD_DATA_BLOCK_NAK, 0xf7
  90:bootloader.c  **** };
  91:bootloader.c  **** 
  92:bootloader.c  **** void midi_sysex_send_ack(void) {
 177               	.LM8:
 178               	.LFBB3:
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 182               	.LM9:
 183 0000 E0E0      		ldi r30,lo8(ack_msg)
 184 0002 F0E0      		ldi r31,hi8(ack_msg)
 185               	.L11:
  93:bootloader.c  ****   uint8_t i;
  94:bootloader.c  ****   for (i = 0; i < sizeof(ack_msg); i++)
  95:bootloader.c  ****     bl_uart_putc(ack_msg[i]);
 187               	.LM10:
 188 0004 8081      		ld r24,Z
 189               	.L10:
 190               	.LBB35:
 191               	.LBB36:
  80:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 193               	.LM11:
 194 0006 5D9B      		sbis 43-32,5
 195 0008 00C0      		rjmp .L10
  82:bootloader.c  ****   UART_WRITE_CHAR(c);
 197               	.LM12:
 198 000a 8CB9      		out 44-32,r24
 199 000c 3196      		adiw r30,1
 200               	.LBE36:
 201               	.LBE35:
  95:bootloader.c  ****   for (i = 0; i < sizeof(ack_msg); i++)
 203               	.LM13:
 204 000e 80E0      		ldi r24,hi8(ack_msg+6)
 205 0010 E030      		cpi r30,lo8(ack_msg+6)
 206 0012 F807      		cpc r31,r24
 207 0014 01F4      		brne .L11
 208               	/* epilogue start */
  96:bootloader.c  **** }  
 210               	.LM14:
 211 0016 0895      		ret
 213               	.Lscope3:
 215               		.stabd	78,0,0
 216               		.section	.text.midi_sysex_send_nak,"ax",@progbits
 218               	.global	midi_sysex_send_nak
 220               	midi_sysex_send_nak:
 221               		.stabd	46,0,0
  97:bootloader.c  **** 
  98:bootloader.c  **** void midi_sysex_send_nak(void) {
 223               	.LM15:
 224               	.LFBB4:
 225               	/* prologue: function */
 226               	/* frame size = 0 */
 228               	.LM16:
 229 0000 E0E0      		ldi r30,lo8(nak_msg)
 230 0002 F0E0      		ldi r31,hi8(nak_msg)
 231               	.L17:
  99:bootloader.c  ****   uint8_t i;
 100:bootloader.c  ****   for (i = 0; i < sizeof(nak_msg); i++)
 101:bootloader.c  ****     bl_uart_putc(nak_msg[i]);
 233               	.LM17:
 234 0004 8081      		ld r24,Z
 235               	.L16:
 236               	.LBB37:
 237               	.LBB38:
  80:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 239               	.LM18:
 240 0006 5D9B      		sbis 43-32,5
 241 0008 00C0      		rjmp .L16
  82:bootloader.c  ****   UART_WRITE_CHAR(c);
 243               	.LM19:
 244 000a 8CB9      		out 44-32,r24
 245 000c 3196      		adiw r30,1
 246               	.LBE38:
 247               	.LBE37:
 101:bootloader.c  ****   for (i = 0; i < sizeof(nak_msg); i++)
 249               	.LM20:
 250 000e 80E0      		ldi r24,hi8(nak_msg+6)
 251 0010 E030      		cpi r30,lo8(nak_msg+6)
 252 0012 F807      		cpc r31,r24
 253 0014 01F4      		brne .L17
 254               	/* epilogue start */
 102:bootloader.c  **** }  
 256               	.LM21:
 257 0016 0895      		ret
 259               	.Lscope4:
 261               		.stabd	78,0,0
 262               		.section	.text.make_word,"ax",@progbits
 266               	.global	make_word
 268               	make_word:
 269               		.stabd	46,0,0
 103:bootloader.c  **** 
 104:bootloader.c  **** uint8_t jump_to_main_program(void) {
 105:bootloader.c  ****   _delay_ms(100);
 106:bootloader.c  ****   if (recvd != 0) {
 107:bootloader.c  ****     write_block_data();
 108:bootloader.c  ****   }
 109:bootloader.c  ****   
 110:bootloader.c  ****   if (check_firmware_checksum()) {
 111:bootloader.c  ****     lcd_line1();
 112:bootloader.c  ****     lcd_clear_line();
 113:bootloader.c  ****     lcd_line2();
 114:bootloader.c  ****     lcd_clear_line();
 115:bootloader.c  **** 		if (eeprom_read_word(START_MAIN_APP_ADDR) != 1) {
 116:bootloader.c  **** 			eeprom_write_word(START_MAIN_APP_ADDR, 1);
 117:bootloader.c  **** 		}
 118:bootloader.c  ****     jump_to_app();
 119:bootloader.c  ****     return 1;
 120:bootloader.c  ****   } else {
 121:bootloader.c  ****     lcd_line2();
 122:bootloader.c  ****     lcd_put((uint8_t *)"WRONG CHECK", 11);
 123:bootloader.c  ****     return 0;
 124:bootloader.c  ****   }
 125:bootloader.c  **** }
 126:bootloader.c  **** 
 127:bootloader.c  **** uint16_t block_cnt = 0;
 128:bootloader.c  **** uint8_t sysex_data[SPM_PAGESIZE];
 129:bootloader.c  **** 
 130:bootloader.c  **** uint8_t data[100];
 131:bootloader.c  **** uint8_t sysex_cnt;
 132:bootloader.c  **** uint8_t in_sysex= 0;
 133:bootloader.c  **** 
 134:bootloader.c  **** uint16_t make_word(uint8_t idx, uint8_t cnt) {
 271               	.LM22:
 272               	.LFBB5:
 273               	/* prologue: function */
 274               	/* frame size = 0 */
 275 0000 782F      		mov r23,r24
 135:bootloader.c  ****   uint8_t ptr = idx + cnt - 1;
 277               	.LM23:
 278 0002 7150      		subi r23,lo8(-(-1))
 279 0004 670F      		add r22,r23
 280 0006 7F5F      		subi r23,lo8(-(1))
 281 0008 20E0      		ldi r18,lo8(0)
 282 000a 30E0      		ldi r19,hi8(0)
 283 000c 40E0      		ldi r20,hlo8(0)
 284 000e 50E0      		ldi r21,hhi8(0)
 285 0010 00C0      		rjmp .L22
 286               	.L23:
 136:bootloader.c  ****   uint32_t ret = 0;
 137:bootloader.c  ****   for (; ptr >= idx; ptr--) {
 138:bootloader.c  ****     ret <<= 7;
 288               	.LM24:
 289 0012 DA01      		movw r26,r20
 290 0014 C901      		movw r24,r18
 291 0016 27E0      		ldi r18,7
 292 0018 880F      	1:	lsl r24
 293 001a 991F      		rol r25
 294 001c AA1F      		rol r26
 295 001e BB1F      		rol r27
 296 0020 2A95      		dec r18
 297 0022 01F4      		brne 1b
 139:bootloader.c  ****     ret |= data[ptr];
 299               	.LM25:
 300 0024 E62F      		mov r30,r22
 301 0026 F0E0      		ldi r31,lo8(0)
 302 0028 E050      		subi r30,lo8(-(data))
 303 002a F040      		sbci r31,hi8(-(data))
 304 002c 2081      		ld r18,Z
 305 002e 30E0      		ldi r19,lo8(0)
 306 0030 40E0      		ldi r20,lo8(0)
 307 0032 50E0      		ldi r21,hi8(0)
 308 0034 282B      		or r18,r24
 309 0036 392B      		or r19,r25
 310 0038 4A2B      		or r20,r26
 311 003a 5B2B      		or r21,r27
 138:bootloader.c  ****   for (; ptr >= idx; ptr--) {
 313               	.LM26:
 314 003c 6150      		subi r22,lo8(-(-1))
 315               	.L22:
 316 003e 6717      		cp r22,r23
 317 0040 00F4      		brsh .L23
 140:bootloader.c  ****   }
 141:bootloader.c  ****   return ret;
 142:bootloader.c  **** }
 319               	.LM27:
 320 0042 C901      		movw r24,r18
 321               	/* epilogue start */
 322 0044 0895      		ret
 328               	.Lscope5:
 330               		.stabd	78,0,0
 331               		.section	.text.check_firmware_checksum,"ax",@progbits
 333               	.global	check_firmware_checksum
 335               	check_firmware_checksum:
 336               		.stabd	46,0,0
  51:bootloader.c  **** uint8_t check_firmware_checksum(void) {
 338               	.LM28:
 339               	.LFBB6:
 340 0000 CF93      		push r28
 341 0002 DF93      		push r29
 342               	/* prologue: function */
 343               	/* frame size = 0 */
  52:bootloader.c  ****   uint16_t len = eeprom_read_word(FIRMWARE_LENGTH_ADDR);
 345               	.LM29:
 346 0004 80E0      		ldi r24,lo8(0)
 347 0006 90E0      		ldi r25,hi8(0)
 348 0008 0E94 0000 		call __eerd_word_m64
 349 000c 9C01      		movw r18,r24
 350 000e E0E0      		ldi r30,lo8(0)
 351 0010 F0E0      		ldi r31,hi8(0)
 352 0012 C0E0      		ldi r28,lo8(0)
 353 0014 D0E0      		ldi r29,hi8(0)
 354 0016 00C0      		rjmp .L26
 355               	.L27:
 356               	.LBB39:
  58:bootloader.c  ****     checksum += pgm_read_byte(i);
 358               	.LM30:
 359               	/* #APP */
 360               	 ;  58 "bootloader.c" 1
 361 0018 8491      		lpm r24, Z
 362               		
 363               	 ;  0 "" 2
 364               	/* #NOAPP */
 365               	.LBE39:
 366 001a C80F      		add r28,r24
 367 001c D11D      		adc r29,__zero_reg__
  57:bootloader.c  ****   for (i = 0; i < len; i++) {
 369               	.LM31:
 370 001e 3196      		adiw r30,1
 371               	.L26:
 372 0020 E217      		cp r30,r18
 373 0022 F307      		cpc r31,r19
 374 0024 00F0      		brlo .L27
  53:bootloader.c  ****   uint16_t firm_checksum = eeprom_read_word(FIRMWARE_CHECKSUM_ADDR);
 376               	.LM32:
 377 0026 82E0      		ldi r24,lo8(2)
 378 0028 90E0      		ldi r25,hi8(2)
 379 002a 0E94 0000 		call __eerd_word_m64
 380 002e 20E0      		ldi r18,lo8(0)
 381 0030 DF73      		andi r29,hi8(16383)
 382 0032 C817      		cp r28,r24
 383 0034 D907      		cpc r29,r25
 384 0036 01F4      		brne .L28
 385 0038 21E0      		ldi r18,lo8(1)
 386               	.L28:
  65:bootloader.c  **** }
 388               	.LM33:
 389 003a 822F      		mov r24,r18
 390               	/* epilogue start */
 391 003c DF91      		pop r29
 392 003e CF91      		pop r28
 393 0040 0895      		ret
 403               	.Lscope6:
 405               		.stabd	78,0,0
 406               		.section	.text.is_button_pressed,"ax",@progbits
 408               	.global	is_button_pressed
 410               	is_button_pressed:
 411               		.stabd	46,0,0
 143:bootloader.c  **** 
 144:bootloader.c  **** uint8_t write_checksum(void) {
 145:bootloader.c  ****   uint16_t len = make_word(4, 3);
 146:bootloader.c  ****   uint16_t checksum = data[7] | (data[8] << 7);
 147:bootloader.c  ****   write_firmware_checksum(len, checksum);
 148:bootloader.c  ****   return 1;
 149:bootloader.c  **** }
 150:bootloader.c  **** 
 151:bootloader.c  **** #if (SPM_PAGESIZE == 64)
 152:bootloader.c  **** #define ADDR_SHIFT_BITS 6
 153:bootloader.c  **** #elif (SPM_PAGESIZE == 128)
 154:bootloader.c  **** #define ADDR_SHIFT_BITS 7
 155:bootloader.c  **** #elif (SPM_PAGESIZE == 256)
 156:bootloader.c  **** #define ADDR_SHIFT_BITS 8
 157:bootloader.c  **** #endif
 158:bootloader.c  **** 
 159:bootloader.c  **** 
 160:bootloader.c  **** 
 161:bootloader.c  **** void write_block_data(void) {
 162:bootloader.c  ****   uint16_t i;
 163:bootloader.c  ****   uint8_t sreg = SREG;
 164:bootloader.c  ****   lcd_line2();
 165:bootloader.c  ****   lcd_put((uint8_t *)"BLK ", 4);
 166:bootloader.c  ****   lcd_putnumberx(sysex_address >> ADDR_SHIFT_BITS);
 167:bootloader.c  ****   cli();
 168:bootloader.c  ****   boot_page_erase(sysex_address);
 169:bootloader.c  ****   boot_spm_busy_wait();
 170:bootloader.c  ****   uint16_t address = sysex_address;
 171:bootloader.c  ****   for (i = 0; i < SPM_PAGESIZE; i+=2) {
 172:bootloader.c  ****     uint16_t tmp = sysex_data[i] | (sysex_data[i + 1] << 8);
 173:bootloader.c  ****     boot_page_fill(address, tmp);
 174:bootloader.c  ****     address += 2;
 175:bootloader.c  ****   }
 176:bootloader.c  ****   boot_page_write(sysex_address);
 177:bootloader.c  ****   boot_spm_busy_wait();
 178:bootloader.c  ****   boot_rww_enable();
 179:bootloader.c  ****   SREG = sreg;
 180:bootloader.c  ****   recvd = 0;
 181:bootloader.c  **** }
 182:bootloader.c  **** 
 183:bootloader.c  **** uint8_t write_block(void) {
 184:bootloader.c  ****   
 185:bootloader.c  ****   uint8_t checksum = 0;
 186:bootloader.c  ****   uint8_t i;
 187:bootloader.c  ****   for (i = 3; i < sysex_cnt - 1; i++) {
 188:bootloader.c  ****     checksum ^= data[i];
 189:bootloader.c  ****   }
 190:bootloader.c  **** 
 191:bootloader.c  ****   uint8_t length = data[4];
 192:bootloader.c  ****   if (recvd == 0) {
 193:bootloader.c  ****     sysex_address = make_word(5, 4);
 194:bootloader.c  ****   }
 195:bootloader.c  **** 
 196:bootloader.c  ****   if (sysex_address >= APP_END) {
 197:bootloader.c  ****     return 0;
 198:bootloader.c  ****   }
 199:bootloader.c  **** 
 200:bootloader.c  ****   uint8_t cnt = 0;
 201:bootloader.c  ****   uint8_t bits = 0;
 202:bootloader.c  ****   i = 0;
 203:bootloader.c  ****   for (cnt = 0; cnt < (sysex_cnt - 9); cnt++) {
 204:bootloader.c  ****     if ((cnt % 8) == 0) {
 205:bootloader.c  ****       bits = data[9 + cnt];
 206:bootloader.c  ****     } else {
 207:bootloader.c  ****       sysex_data[recvd++] = data[9 + cnt] | ((bits & 1) << 7);
 208:bootloader.c  ****       i++;
 209:bootloader.c  ****       bits >>= 1;
 210:bootloader.c  ****     }
 211:bootloader.c  ****     if (i >= length)
 212:bootloader.c  ****       break;
 213:bootloader.c  ****   }
 214:bootloader.c  ****   
 215:bootloader.c  ****   uint8_t check = data[sysex_cnt - 1];
 216:bootloader.c  ****   checksum &= 0x7f;
 217:bootloader.c  **** 
 218:bootloader.c  ****   if ((checksum != check) || (i != 64)) {
 219:bootloader.c  ****     return 0;
 220:bootloader.c  ****   }
 221:bootloader.c  **** 
 222:bootloader.c  ****   if (recvd == SPM_PAGESIZE) {
 223:bootloader.c  ****     write_block_data();
 224:bootloader.c  ****   }
 225:bootloader.c  ****   
 226:bootloader.c  ****   return 1;
 227:bootloader.c  **** }
 228:bootloader.c  **** 
 229:bootloader.c  **** void handle_sysex(void) {
 230:bootloader.c  ****   uint8_t res = 0;
 231:bootloader.c  ****   if (sysex_cnt < 4) {
 232:bootloader.c  ****     return;
 233:bootloader.c  ****   } else {
 234:bootloader.c  ****     if (data[3] == CMD_START_BOOTLOADER) {
 235:bootloader.c  ****       res = 1;
 236:bootloader.c  ****     } else if (data[3] == CMD_MAIN_PROGRAM) {
 237:bootloader.c  ****       res = jump_to_main_program();
 238:bootloader.c  ****     } else if (data[3] == CMD_BOOT_DATA_BLOCK) {
 239:bootloader.c  ****       res = write_block();
 240:bootloader.c  ****     } else if (data[3] == CMD_FIRMWARE_CHECKSUM && sysex_cnt == 9) {
 241:bootloader.c  ****       res = write_checksum();
 242:bootloader.c  ****     }
 243:bootloader.c  **** 
 244:bootloader.c  ****     if (res)
 245:bootloader.c  ****       midi_sysex_send_ack();
 246:bootloader.c  ****     else
 247:bootloader.c  ****       midi_sysex_send_nak();
 248:bootloader.c  ****   }
 249:bootloader.c  **** }
 250:bootloader.c  **** 
 251:bootloader.c  **** void handle_midi(uint8_t c) {
 252:bootloader.c  ****   if (c == 0xF0) {
 253:bootloader.c  ****     if (in_sysex == 1) {
 254:bootloader.c  ****       handle_sysex();
 255:bootloader.c  ****     }
 256:bootloader.c  ****     sysex_cnt = 0;
 257:bootloader.c  ****     in_sysex = 1;
 258:bootloader.c  ****     return;
 259:bootloader.c  ****   } else if (c == 0xF7) {
 260:bootloader.c  ****     if (in_sysex == 1) {
 261:bootloader.c  ****       handle_sysex();
 262:bootloader.c  ****     }
 263:bootloader.c  ****     in_sysex = 0;
 264:bootloader.c  ****     return;
 265:bootloader.c  ****   } else if (MIDI_IS_STATUS_BYTE(c)) {
 266:bootloader.c  ****     in_sysex = 0;
 267:bootloader.c  ****     return;
 268:bootloader.c  ****   }
 269:bootloader.c  ****   
 270:bootloader.c  ****   if (in_sysex) {
 271:bootloader.c  ****     data[sysex_cnt++] = c;
 272:bootloader.c  ****     if (sysex_cnt >= 3) {
 273:bootloader.c  ****       if (data[0] != SYSEX_VENDOR_1 ||
 274:bootloader.c  **** 	  data[1] != SYSEX_VENDOR_2 ||
 275:bootloader.c  **** 	  data[2] != SYSEX_VENDOR_3) {
 276:bootloader.c  **** 	in_sysex = 0;
 277:bootloader.c  ****       }
 278:bootloader.c  ****     }
 279:bootloader.c  ****     if (sysex_cnt > 100) {
 280:bootloader.c  ****       /* discard too long message */
 281:bootloader.c  ****       in_sysex = 0;
 282:bootloader.c  ****     }
 283:bootloader.c  ****   }
 284:bootloader.c  **** }
 285:bootloader.c  **** 
 286:bootloader.c  **** uint8_t is_button_pressed() {
 413               	.LM34:
 414               	.LFBB7:
 415               	/* prologue: function */
 416               	/* frame size = 0 */
 287:bootloader.c  ****   return !(sr165_read() & 0x80);
 418               	.LM35:
 419 0000 0E94 0000 		call sr165_read
 420 0004 8095      		com r24
 288:bootloader.c  **** }
 422               	.LM36:
 423 0006 881F      		rol r24
 424 0008 8827      		clr r24
 425 000a 881F      		rol r24
 426               	/* epilogue start */
 427 000c 0895      		ret
 429               	.Lscope7:
 431               		.stabd	78,0,0
 432               		.data
 433               	.LC0:
 434 0000 424C 4B20 		.string	"BLK "
 434      00
 435               		.section	.text.write_block_data,"ax",@progbits
 437               	.global	write_block_data
 439               	write_block_data:
 440               		.stabd	46,0,0
 162:bootloader.c  **** void write_block_data(void) {
 442               	.LM37:
 443               	.LFBB8:
 444 0000 1F93      		push r17
 445 0002 CF93      		push r28
 446 0004 DF93      		push r29
 447               	/* prologue: function */
 448               	/* frame size = 0 */
 164:bootloader.c  ****   uint8_t sreg = SREG;
 450               	.LM38:
 451 0006 1FB7      		in r17,__SREG__
 165:bootloader.c  ****   lcd_line2();
 453               	.LM39:
 454 0008 0E94 0000 		call lcd_line2
 166:bootloader.c  ****   lcd_put((uint8_t *)"BLK ", 4);
 456               	.LM40:
 457 000c 80E0      		ldi r24,lo8(.LC0)
 458 000e 90E0      		ldi r25,hi8(.LC0)
 459 0010 64E0      		ldi r22,lo8(4)
 460 0012 0E94 0000 		call lcd_put
 167:bootloader.c  ****   lcd_putnumberx(sysex_address >> ADDR_SHIFT_BITS);
 462               	.LM41:
 463 0016 8091 0000 		lds r24,sysex_address+1
 464 001a 0E94 0000 		call lcd_putnumberx
 168:bootloader.c  ****   cli();
 466               	.LM42:
 467               	/* #APP */
 468               	 ;  168 "bootloader.c" 1
 469 001e F894      		cli
 470               	 ;  0 "" 2
 169:bootloader.c  ****   boot_page_erase(sysex_address);
 472               	.LM43:
 473               	/* #NOAPP */
 474 0020 6091 0000 		lds r22,sysex_address
 475 0024 7091 0000 		lds r23,(sysex_address)+1
 476 0028 83E0      		ldi r24,lo8(3)
 477 002a FB01      		movw r30,r22
 478               	/* #APP */
 479               	 ;  169 "bootloader.c" 1
 480 002c 8093 6800 		sts 104, r24
 481 0030 E895      		spm
 482               		
 483               	 ;  0 "" 2
 484               	/* #NOAPP */
 485               	.L34:
 170:bootloader.c  ****   boot_spm_busy_wait();
 487               	.LM44:
 488 0032 8091 6800 		lds r24,104
 489 0036 80FD      		sbrc r24,0
 490 0038 00C0      		rjmp .L34
 491 003a C0E0      		ldi r28,lo8(sysex_data)
 492 003c D0E0      		ldi r29,hi8(sysex_data)
 493 003e AB01      		movw r20,r22
 494               	.LBB40:
 174:bootloader.c  ****     boot_page_fill(address, tmp);
 496               	.LM45:
 497 0040 A1E0      		ldi r26,lo8(1)
 498               	.L35:
 499 0042 3981      		ldd r19,Y+1
 500 0044 20E0      		ldi r18,lo8(0)
 501 0046 8881      		ld r24,Y
 502 0048 90E0      		ldi r25,lo8(0)
 503 004a 822B      		or r24,r18
 504 004c 932B      		or r25,r19
 505 004e FA01      		movw r30,r20
 506               	/* #APP */
 507               	 ;  174 "bootloader.c" 1
 508 0050 0C01      		movw  r0, r24
 509 0052 A093 6800 		sts 104, r26
 510 0056 E895      		spm
 511 0058 1124      		clr  r1
 512               		
 513               	 ;  0 "" 2
 175:bootloader.c  ****     address += 2;
 515               	.LM46:
 516               	/* #NOAPP */
 517 005a 4E5F      		subi r20,lo8(-(2))
 518 005c 5F4F      		sbci r21,hi8(-(2))
 519 005e 2296      		adiw r28,2
 520               	.LBE40:
 172:bootloader.c  ****   for (i = 0; i < SPM_PAGESIZE; i+=2) {
 522               	.LM47:
 523 0060 F0E0      		ldi r31,hi8(sysex_data+256)
 524 0062 C030      		cpi r28,lo8(sysex_data+256)
 525 0064 DF07      		cpc r29,r31
 526 0066 01F4      		brne .L35
 177:bootloader.c  ****   boot_page_write(sysex_address);
 528               	.LM48:
 529 0068 85E0      		ldi r24,lo8(5)
 530 006a FB01      		movw r30,r22
 531               	/* #APP */
 532               	 ;  177 "bootloader.c" 1
 533 006c 8093 6800 		sts 104, r24
 534 0070 E895      		spm
 535               		
 536               	 ;  0 "" 2
 537               	/* #NOAPP */
 538               	.L36:
 178:bootloader.c  ****   boot_spm_busy_wait();
 540               	.LM49:
 541 0072 8091 6800 		lds r24,104
 542 0076 80FD      		sbrc r24,0
 543 0078 00C0      		rjmp .L36
 179:bootloader.c  ****   boot_rww_enable();
 545               	.LM50:
 546 007a 81E1      		ldi r24,lo8(17)
 547               	/* #APP */
 548               	 ;  179 "bootloader.c" 1
 549 007c 8093 6800 		sts 104, r24
 550 0080 E895      		spm
 551               		
 552               	 ;  0 "" 2
 180:bootloader.c  ****   SREG = sreg;
 554               	.LM51:
 555               	/* #NOAPP */
 556 0082 1FBF      		out __SREG__,r17
 181:bootloader.c  ****   recvd = 0;
 558               	.LM52:
 559 0084 1092 0000 		sts (recvd)+1,__zero_reg__
 560 0088 1092 0000 		sts recvd,__zero_reg__
 561               	/* epilogue start */
 182:bootloader.c  **** }
 563               	.LM53:
 564 008c DF91      		pop r29
 565 008e CF91      		pop r28
 566 0090 1F91      		pop r17
 567 0092 0895      		ret
 573               	.Lscope8:
 575               		.stabd	78,0,0
 576               		.section	.text.write_block,"ax",@progbits
 578               	.global	write_block
 580               	write_block:
 581               		.stabd	46,0,0
 184:bootloader.c  **** uint8_t write_block(void) {
 583               	.LM54:
 584               	.LFBB9:
 585 0000 EF92      		push r14
 586 0002 FF92      		push r15
 587 0004 0F93      		push r16
 588 0006 1F93      		push r17
 589 0008 CF93      		push r28
 590 000a DF93      		push r29
 591               	/* prologue: function */
 592               	/* frame size = 0 */
 188:bootloader.c  ****   for (i = 3; i < sysex_cnt - 1; i++) {
 594               	.LM55:
 595 000c 8091 0000 		lds r24,sysex_cnt
 596 0010 E82E      		mov r14,r24
 597 0012 FF24      		clr r15
 598 0014 E701      		movw r28,r14
 599 0016 2197      		sbiw r28,1
 600 0018 10E0      		ldi r17,lo8(0)
 601 001a 93E0      		ldi r25,lo8(3)
 602 001c 00C0      		rjmp .L42
 603               	.L43:
 189:bootloader.c  ****     checksum ^= data[i];
 605               	.LM56:
 606 001e E050      		subi r30,lo8(-(data))
 607 0020 F040      		sbci r31,hi8(-(data))
 608 0022 8081      		ld r24,Z
 609 0024 1827      		eor r17,r24
 188:bootloader.c  ****   for (i = 3; i < sysex_cnt - 1; i++) {
 611               	.LM57:
 612 0026 9F5F      		subi r25,lo8(-(1))
 613               	.L42:
 614 0028 E92F      		mov r30,r25
 615 002a F0E0      		ldi r31,lo8(0)
 616 002c EC17      		cp r30,r28
 617 002e FD07      		cpc r31,r29
 618 0030 04F0      		brlt .L43
 192:bootloader.c  ****   uint8_t length = data[4];
 620               	.LM58:
 621 0032 0091 0000 		lds r16,data+4
 193:bootloader.c  ****   if (recvd == 0) {
 623               	.LM59:
 624 0036 6091 0000 		lds r22,recvd
 625 003a 7091 0000 		lds r23,(recvd)+1
 626 003e 6115      		cp r22,__zero_reg__
 627 0040 7105      		cpc r23,__zero_reg__
 628 0042 01F4      		brne .L44
 629 0044 E0E0      		ldi r30,lo8(data+8)
 630 0046 F0E0      		ldi r31,hi8(data+8)
 631 0048 20E0      		ldi r18,lo8(0)
 632 004a 30E0      		ldi r19,hi8(0)
 633 004c 40E0      		ldi r20,hlo8(0)
 634 004e 50E0      		ldi r21,hhi8(0)
 635               	.L45:
 636               	.LBB41:
 637               	.LBB42:
 139:bootloader.c  ****     ret <<= 7;
 639               	.LM60:
 640 0050 A7E0      		ldi r26,7
 641 0052 220F      	1:	lsl r18
 642 0054 331F      		rol r19
 643 0056 441F      		rol r20
 644 0058 551F      		rol r21
 645 005a AA95      		dec r26
 646 005c 01F4      		brne 1b
 140:bootloader.c  ****     ret |= data[ptr];
 648               	.LM61:
 649 005e 8081      		ld r24,Z
 650 0060 90E0      		ldi r25,lo8(0)
 651 0062 A0E0      		ldi r26,lo8(0)
 652 0064 B0E0      		ldi r27,hi8(0)
 653 0066 282B      		or r18,r24
 654 0068 392B      		or r19,r25
 655 006a 4A2B      		or r20,r26
 656 006c 5B2B      		or r21,r27
 657 006e 3197      		sbiw r30,1
 138:bootloader.c  ****   for (; ptr >= idx; ptr--) {
 659               	.LM62:
 660 0070 80E0      		ldi r24,hi8(data+4)
 661 0072 E030      		cpi r30,lo8(data+4)
 662 0074 F807      		cpc r31,r24
 663 0076 01F4      		brne .L45
 664               	.LBE42:
 665               	.LBE41:
 194:bootloader.c  ****     sysex_address = make_word(5, 4);
 667               	.LM63:
 668 0078 3093 0000 		sts (sysex_address)+1,r19
 669 007c 2093 0000 		sts sysex_address,r18
 670               	.L44:
 197:bootloader.c  ****   if (sysex_address >= APP_END) {
 672               	.LM64:
 673 0080 8091 0000 		lds r24,sysex_address
 674 0084 9091 0000 		lds r25,(sysex_address)+1
 675 0088 8050      		subi r24,lo8(-4096)
 676 008a 904F      		sbci r25,hi8(-4096)
 677 008c 00F0      		brlo .+2
 678 008e 00C0      		rjmp .L46
 679 0090 40E0      		ldi r20,lo8(0)
 680 0092 30E0      		ldi r19,lo8(0)
 681 0094 20E0      		ldi r18,lo8(0)
 204:bootloader.c  ****   for (cnt = 0; cnt < (sysex_cnt - 9); cnt++) {
 683               	.LM65:
 684 0096 87EF      		ldi r24,lo8(-9)
 685 0098 9FEF      		ldi r25,hi8(-9)
 686 009a E80E      		add r14,r24
 687 009c F91E      		adc r15,r25
 688 009e 00C0      		rjmp .L47
 689               	.L52:
 690 00a0 DC01      		movw r26,r24
 691 00a2 A050      		subi r26,lo8(-(data))
 692 00a4 B040      		sbci r27,hi8(-(data))
 205:bootloader.c  ****     if ((cnt % 8) == 0) {
 694               	.LM66:
 695 00a6 8770      		andi r24,lo8(7)
 696 00a8 9070      		andi r25,hi8(7)
 697 00aa 892B      		or r24,r25
 698 00ac 01F4      		brne .L48
 206:bootloader.c  ****       bits = data[9 + cnt];
 700               	.LM67:
 701 00ae 1996      		adiw r26,9
 702 00b0 2C91      		ld r18,X
 703 00b2 00C0      		rjmp .L49
 704               	.L48:
 208:bootloader.c  ****       sysex_data[recvd++] = data[9 + cnt] | ((bits & 1) << 7);
 706               	.LM68:
 707 00b4 FB01      		movw r30,r22
 708 00b6 E050      		subi r30,lo8(-(sysex_data))
 709 00b8 F040      		sbci r31,hi8(-(sysex_data))
 710 00ba 822F      		mov r24,r18
 711 00bc 8795      		ror r24
 712 00be 8827      		clr r24
 713 00c0 8795      		ror r24
 714 00c2 1996      		adiw r26,9
 715 00c4 9C91      		ld r25,X
 716 00c6 892B      		or r24,r25
 717 00c8 8083      		st Z,r24
 718 00ca 6F5F      		subi r22,lo8(-(1))
 719 00cc 7F4F      		sbci r23,hi8(-(1))
 209:bootloader.c  ****       i++;
 721               	.LM69:
 722 00ce 4F5F      		subi r20,lo8(-(1))
 210:bootloader.c  ****       bits >>= 1;
 724               	.LM70:
 725 00d0 2695      		lsr r18
 726               	.L49:
 212:bootloader.c  ****     if (i >= length)
 728               	.LM71:
 729 00d2 4017      		cp r20,r16
 730 00d4 00F4      		brsh .L57
 731               	.L50:
 204:bootloader.c  ****   for (cnt = 0; cnt < (sysex_cnt - 9); cnt++) {
 733               	.LM72:
 734 00d6 3F5F      		subi r19,lo8(-(1))
 735               	.L47:
 736 00d8 832F      		mov r24,r19
 737 00da 90E0      		ldi r25,lo8(0)
 738 00dc 8E15      		cp r24,r14
 739 00de 9F05      		cpc r25,r15
 740 00e0 04F0      		brlt .L52
 741               	.L57:
 742 00e2 7093 0000 		sts (recvd)+1,r23
 743 00e6 6093 0000 		sts recvd,r22
 219:bootloader.c  ****   if ((checksum != check) || (i != 64)) {
 745               	.LM73:
 746 00ea 1F77      		andi r17,lo8(127)
 747 00ec C050      		subi r28,lo8(-(data))
 748 00ee D040      		sbci r29,hi8(-(data))
 749 00f0 8881      		ld r24,Y
 750 00f2 1817      		cp r17,r24
 751 00f4 01F4      		brne .L46
 752 00f6 4034      		cpi r20,lo8(64)
 753 00f8 01F4      		brne .L46
 223:bootloader.c  ****   if (recvd == SPM_PAGESIZE) {
 755               	.LM74:
 756 00fa 8091 0000 		lds r24,recvd
 757 00fe 9091 0000 		lds r25,(recvd)+1
 758 0102 8050      		subi r24,lo8(256)
 759 0104 9140      		sbci r25,hi8(256)
 760 0106 01F4      		brne .L58
 761               	.L53:
 224:bootloader.c  ****     write_block_data();
 763               	.LM75:
 764 0108 0E94 0000 		call write_block_data
 765               	.L58:
 766 010c 81E0      		ldi r24,lo8(1)
 767 010e 00C0      		rjmp .L54
 768               	.L46:
 769 0110 80E0      		ldi r24,lo8(0)
 770               	.L54:
 771               	/* epilogue start */
 228:bootloader.c  **** }
 773               	.LM76:
 774 0112 CDB7      		in r28,__SP_L__
 775 0114 DEB7      		in r29,__SP_H__
 776 0116 E6E0      		ldi r30, lo8(6)
 777 0118 0C94 0000 		jmp __epilogue_restores__ + ((18 - 6) * 2)
 786               	.Lscope9:
 788               		.stabd	78,0,0
 789               		.data
 790               	.LC1:
 791 0005 5752 4F4E 		.string	"WRONG CHECK"
 791      4720 4348 
 791      4543 4B00 
 792               		.section	.text.jump_to_main_program,"ax",@progbits
 794               	.global	jump_to_main_program
 796               	jump_to_main_program:
 797               		.stabd	46,0,0
 105:bootloader.c  **** uint8_t jump_to_main_program(void) {
 799               	.LM77:
 800               	.LFBB10:
 801               	/* prologue: function */
 802               	/* frame size = 0 */
 105:bootloader.c  **** uint8_t jump_to_main_program(void) {
 804               	.LM78:
 805 0000 88EE      		ldi r24,lo8(1000)
 806 0002 93E0      		ldi r25,hi8(1000)
 807               	.LBB43:
 808               	.LBB44:
 809               	.LBB45:
 810               	.LBB46:
 812               	.Ltext1:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \file */
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \code
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \endcode
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #endif
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     register.
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     can be achieved.
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	);
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** }
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     counter register pair.
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****  */
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 814               	.LM79:
 815 0004 20E9      		ldi r18,lo8(400)
 816 0006 31E0      		ldi r19,hi8(400)
 817               	.L60:
 818 0008 F901      		movw r30,r18
 819               	/* #APP */
 820               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 821 000a 3197      		1: sbiw r30,1
 822 000c 01F4      		brne 1b
 823               	 ;  0 "" 2
 824               	/* #NOAPP */
 825               	.LBE46:
 826               	.LBE45:
 828               	.Ltext2:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /** \file */
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \code
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \endcode
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     used.
  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     routines linked into the application.
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** */
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef F_CPU
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /**
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    \ingroup util_delay
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 105:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 106:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 107:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****  */
 108:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** void
 109:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 110:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** {
 111:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 112:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 113:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 114:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		__ticks = 1;
 115:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 116:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	{
 117:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 118:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 119:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		while(__ticks)
 120:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		{
 121:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 122:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 123:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			__ticks --;
 830               	.LM80:
 831 000e 0197      		sbiw r24,1
 120:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		while(__ticks)
 833               	.LM81:
 834 0010 01F4      		brne .L60
 835               	.LBE44:
 836               	.LBE43:
 838               	.Ltext3:
 107:bootloader.c  ****   if (recvd != 0) {
 840               	.LM82:
 841 0012 8091 0000 		lds r24,recvd
 842 0016 9091 0000 		lds r25,(recvd)+1
 843 001a 892B      		or r24,r25
 844 001c 01F0      		breq .L61
 108:bootloader.c  ****     write_block_data();
 846               	.LM83:
 847 001e 0E94 0000 		call write_block_data
 848               	.L61:
 111:bootloader.c  ****   if (check_firmware_checksum()) {
 850               	.LM84:
 851 0022 0E94 0000 		call check_firmware_checksum
 852 0026 8823      		tst r24
 853 0028 01F0      		breq .L62
 112:bootloader.c  ****     lcd_line1();
 855               	.LM85:
 856 002a 0E94 0000 		call lcd_line1
 113:bootloader.c  ****     lcd_clear_line();
 858               	.LM86:
 859 002e 0E94 0000 		call lcd_clear_line
 114:bootloader.c  ****     lcd_line2();
 861               	.LM87:
 862 0032 0E94 0000 		call lcd_line2
 115:bootloader.c  ****     lcd_clear_line();
 864               	.LM88:
 865 0036 0E94 0000 		call lcd_clear_line
 116:bootloader.c  **** 		if (eeprom_read_word(START_MAIN_APP_ADDR) != 1) {
 867               	.LM89:
 868 003a 84E0      		ldi r24,lo8(4)
 869 003c 90E0      		ldi r25,hi8(4)
 870 003e 0E94 0000 		call __eerd_word_m64
 871 0042 0197      		sbiw r24,1
 872 0044 01F0      		breq .L63
 117:bootloader.c  **** 			eeprom_write_word(START_MAIN_APP_ADDR, 1);
 874               	.LM90:
 875 0046 84E0      		ldi r24,lo8(4)
 876 0048 90E0      		ldi r25,hi8(4)
 877 004a 61E0      		ldi r22,lo8(1)
 878 004c 70E0      		ldi r23,hi8(1)
 879 004e 0E94 0000 		call __eewr_word_m64
 880               	.L63:
 119:bootloader.c  ****     jump_to_app();
 882               	.LM91:
 883 0052 E091 0000 		lds r30,jump_to_app
 884 0056 F091 0000 		lds r31,(jump_to_app)+1
 885 005a 0995      		icall
 886 005c 81E0      		ldi r24,lo8(1)
 887 005e 0895      		ret
 888               	.L62:
 122:bootloader.c  ****     lcd_line2();
 890               	.LM92:
 891 0060 0E94 0000 		call lcd_line2
 123:bootloader.c  ****     lcd_put((uint8_t *)"WRONG CHECK", 11);
 893               	.LM93:
 894 0064 80E0      		ldi r24,lo8(.LC1)
 895 0066 90E0      		ldi r25,hi8(.LC1)
 896 0068 6BE0      		ldi r22,lo8(11)
 897 006a 0E94 0000 		call lcd_put
 898 006e 80E0      		ldi r24,lo8(0)
 126:bootloader.c  **** }
 900               	.LM94:
 901 0070 0895      		ret
 909               	.Lscope10:
 911               		.stabd	78,0,0
 912               		.section	.text.write_firmware_checksum,"ax",@progbits
 916               	.global	write_firmware_checksum
 918               	write_firmware_checksum:
 919               		.stabd	46,0,0
  67:bootloader.c  **** void write_firmware_checksum(uint16_t len, uint16_t checksum) {
 921               	.LM95:
 922               	.LFBB11:
 923 0000 0F93      		push r16
 924 0002 1F93      		push r17
 925               	/* prologue: function */
 926               	/* frame size = 0 */
 927 0004 9C01      		movw r18,r24
 928 0006 8B01      		movw r16,r22
  68:bootloader.c  ****   eeprom_write_word(FIRMWARE_LENGTH_ADDR, len);
 930               	.LM96:
 931 0008 80E0      		ldi r24,lo8(0)
 932 000a 90E0      		ldi r25,hi8(0)
 933 000c B901      		movw r22,r18
 934 000e 0E94 0000 		call __eewr_word_m64
  69:bootloader.c  ****   eeprom_write_word(FIRMWARE_CHECKSUM_ADDR, checksum);
 936               	.LM97:
 937 0012 82E0      		ldi r24,lo8(2)
 938 0014 90E0      		ldi r25,hi8(2)
 939 0016 B801      		movw r22,r16
 940 0018 0E94 0000 		call __eewr_word_m64
  70:bootloader.c  ****   eeprom_write_word(START_MAIN_APP_ADDR, 1);
 942               	.LM98:
 943 001c 84E0      		ldi r24,lo8(4)
 944 001e 90E0      		ldi r25,hi8(4)
 945 0020 61E0      		ldi r22,lo8(1)
 946 0022 70E0      		ldi r23,hi8(1)
 947 0024 0E94 0000 		call __eewr_word_m64
 948               	/* epilogue start */
  71:bootloader.c  **** }
 950               	.LM99:
 951 0028 1F91      		pop r17
 952 002a 0F91      		pop r16
 953 002c 0895      		ret
 955               	.Lscope11:
 957               		.stabd	78,0,0
 958               		.section	.text.write_checksum,"ax",@progbits
 960               	.global	write_checksum
 962               	write_checksum:
 963               		.stabd	46,0,0
 145:bootloader.c  **** uint8_t write_checksum(void) {
 965               	.LM100:
 966               	.LFBB12:
 967               	/* prologue: function */
 968               	/* frame size = 0 */
 969               	.LBB47:
 970               	.LBB48:
 139:bootloader.c  ****     ret <<= 7;
 972               	.LM101:
 973 0000 8091 0000 		lds r24,data+6
 974 0004 90E0      		ldi r25,lo8(0)
 975 0006 A0E0      		ldi r26,lo8(0)
 976 0008 B0E0      		ldi r27,hi8(0)
 977 000a 37E0      		ldi r19,7
 978 000c 880F      	1:	lsl r24
 979 000e 991F      		rol r25
 980 0010 AA1F      		rol r26
 981 0012 BB1F      		rol r27
 982 0014 3A95      		dec r19
 983 0016 01F4      		brne 1b
 140:bootloader.c  ****     ret |= data[ptr];
 985               	.LM102:
 986 0018 2091 0000 		lds r18,data+5
 987 001c 30E0      		ldi r19,lo8(0)
 988 001e 40E0      		ldi r20,lo8(0)
 989 0020 50E0      		ldi r21,hi8(0)
 990 0022 822B      		or r24,r18
 991 0024 932B      		or r25,r19
 992 0026 A42B      		or r26,r20
 993 0028 B52B      		or r27,r21
 139:bootloader.c  ****     ret <<= 7;
 995               	.LM103:
 996 002a 27E0      		ldi r18,7
 997 002c 880F      	1:	lsl r24
 998 002e 991F      		rol r25
 999 0030 AA1F      		rol r26
 1000 0032 BB1F      		rol r27
 1001 0034 2A95      		dec r18
 1002 0036 01F4      		brne 1b
 1003               	.LBE48:
 1004               	.LBE47:
 148:bootloader.c  ****   write_firmware_checksum(len, checksum);
 1006               	.LM104:
 1007 0038 2091 0000 		lds r18,data+4
 1008 003c 30E0      		ldi r19,lo8(0)
 1009 003e 40E0      		ldi r20,lo8(0)
 1010 0040 50E0      		ldi r21,hi8(0)
 1011 0042 822B      		or r24,r18
 1012 0044 932B      		or r25,r19
 1013 0046 A42B      		or r26,r20
 1014 0048 B52B      		or r27,r21
 1015 004a 6091 0000 		lds r22,data+8
 1016 004e 70E0      		ldi r23,lo8(0)
 1017 0050 7695      		lsr r23
 1018 0052 762F      		mov r23,r22
 1019 0054 6627      		clr r22
 1020 0056 7795      		ror r23
 1021 0058 6795      		ror r22
 1022 005a 2091 0000 		lds r18,data+7
 1023 005e 30E0      		ldi r19,lo8(0)
 1024 0060 622B      		or r22,r18
 1025 0062 732B      		or r23,r19
 1026 0064 0E94 0000 		call write_firmware_checksum
 150:bootloader.c  **** }
 1028               	.LM105:
 1029 0068 81E0      		ldi r24,lo8(1)
 1030               	/* epilogue start */
 1031 006a 0895      		ret
 1033               	.Lscope12:
 1035               		.stabd	78,0,0
 1036               		.section	.text.handle_sysex,"ax",@progbits
 1038               	.global	handle_sysex
 1040               	handle_sysex:
 1041               		.stabd	46,0,0
 230:bootloader.c  **** void handle_sysex(void) {
 1043               	.LM106:
 1044               	.LFBB13:
 1045               	/* prologue: function */
 1046               	/* frame size = 0 */
 232:bootloader.c  ****   if (sysex_cnt < 4) {
 1048               	.LM107:
 1049 0000 9091 0000 		lds r25,sysex_cnt
 1050 0004 9430      		cpi r25,lo8(4)
 1051 0006 00F0      		brlo .L82
 235:bootloader.c  ****     if (data[3] == CMD_START_BOOTLOADER) {
 1053               	.LM108:
 1054 0008 8091 0000 		lds r24,data+3
 1055 000c 8530      		cpi r24,lo8(5)
 1056 000e 01F0      		breq .L73
 237:bootloader.c  ****     } else if (data[3] == CMD_MAIN_PROGRAM) {
 1058               	.LM109:
 1059 0010 8430      		cpi r24,lo8(4)
 1060 0012 01F4      		brne .L74
 238:bootloader.c  ****       res = jump_to_main_program();
 1062               	.LM110:
 1063 0014 0E94 0000 		call jump_to_main_program
 1064 0018 00C0      		rjmp .L75
 1065               	.L74:
 239:bootloader.c  ****     } else if (data[3] == CMD_BOOT_DATA_BLOCK) {
 1067               	.LM111:
 1068 001a 8130      		cpi r24,lo8(1)
 1069 001c 01F4      		brne .L76
 240:bootloader.c  ****       res = write_block();
 1071               	.LM112:
 1072 001e 0E94 0000 		call write_block
 1073 0022 00C0      		rjmp .L75
 1074               	.L76:
 241:bootloader.c  ****     } else if (data[3] == CMD_FIRMWARE_CHECKSUM && sysex_cnt == 9) {
 1076               	.LM113:
 1077 0024 8330      		cpi r24,lo8(3)
 1078 0026 01F4      		brne .L77
 1079 0028 9930      		cpi r25,lo8(9)
 1080 002a 01F4      		brne .L77
 242:bootloader.c  ****       res = write_checksum();
 1082               	.LM114:
 1083 002c 0E94 0000 		call write_checksum
 1084               	.L75:
 245:bootloader.c  ****     if (res)
 1086               	.LM115:
 1087 0030 8823      		tst r24
 1088 0032 01F4      		brne .L73
 1089               	.L77:
 1090 0034 E0E0      		ldi r30,lo8(nak_msg)
 1091 0036 F0E0      		ldi r31,hi8(nak_msg)
 1092 0038 00C0      		rjmp .L78
 1093               	.L73:
 1094 003a E0E0      		ldi r30,lo8(ack_msg)
 1095 003c F0E0      		ldi r31,hi8(ack_msg)
 1096               	.L80:
 1097               	.LBB49:
 1098               	.LBB50:
  96:bootloader.c  ****     bl_uart_putc(ack_msg[i]);
 1100               	.LM116:
 1101 003e 8081      		ld r24,Z
 1102               	.L79:
 1103               	.LBB51:
 1104               	.LBB52:
  80:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 1106               	.LM117:
 1107 0040 5D9B      		sbis 43-32,5
 1108 0042 00C0      		rjmp .L79
  82:bootloader.c  ****   UART_WRITE_CHAR(c);
 1110               	.LM118:
 1111 0044 8CB9      		out 44-32,r24
 1112 0046 3196      		adiw r30,1
 1113               	.LBE52:
 1114               	.LBE51:
  95:bootloader.c  ****   for (i = 0; i < sizeof(ack_msg); i++)
 1116               	.LM119:
 1117 0048 80E0      		ldi r24,hi8(ack_msg+6)
 1118 004a E030      		cpi r30,lo8(ack_msg+6)
 1119 004c F807      		cpc r31,r24
 1120 004e 01F4      		brne .L80
 1121 0050 0895      		ret
 1122               	.L78:
 1123               	.LBE50:
 1124               	.LBE49:
 1125               	.LBB53:
 1126               	.LBB54:
 102:bootloader.c  ****     bl_uart_putc(nak_msg[i]);
 1128               	.LM120:
 1129 0052 8081      		ld r24,Z
 1130               	.L81:
 1131               	.LBB55:
 1132               	.LBB56:
  80:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 1134               	.LM121:
 1135 0054 5D9B      		sbis 43-32,5
 1136 0056 00C0      		rjmp .L81
  82:bootloader.c  ****   UART_WRITE_CHAR(c);
 1138               	.LM122:
 1139 0058 8CB9      		out 44-32,r24
 1140 005a 3196      		adiw r30,1
 1141               	.LBE56:
 1142               	.LBE55:
 101:bootloader.c  ****   for (i = 0; i < sizeof(nak_msg); i++)
 1144               	.LM123:
 1145 005c 80E0      		ldi r24,hi8(nak_msg+6)
 1146 005e E030      		cpi r30,lo8(nak_msg+6)
 1147 0060 F807      		cpc r31,r24
 1148 0062 01F4      		brne .L78
 1149               	.L82:
 1150 0064 0895      		ret
 1151               	.LBE54:
 1152               	.LBE53:
 1157               	.Lscope13:
 1159               		.stabd	78,0,0
 1160               		.section	.text.handle_midi,"ax",@progbits
 1163               	.global	handle_midi
 1165               	handle_midi:
 1166               		.stabd	46,0,0
 252:bootloader.c  **** void handle_midi(uint8_t c) {
 1168               	.LM124:
 1169               	.LFBB14:
 1170               	/* prologue: function */
 1171               	/* frame size = 0 */
 1172 0000 982F      		mov r25,r24
 253:bootloader.c  ****   if (c == 0xF0) {
 1174               	.LM125:
 1175 0002 803F      		cpi r24,lo8(-16)
 1176 0004 01F4      		brne .L88
 254:bootloader.c  ****     if (in_sysex == 1) {
 1178               	.LM126:
 1179 0006 8091 0000 		lds r24,in_sysex
 1180 000a 8130      		cpi r24,lo8(1)
 1181 000c 01F4      		brne .L89
 255:bootloader.c  ****       handle_sysex();
 1183               	.LM127:
 1184 000e 0E94 0000 		call handle_sysex
 1185               	.L89:
 257:bootloader.c  ****     sysex_cnt = 0;
 1187               	.LM128:
 1188 0012 1092 0000 		sts sysex_cnt,__zero_reg__
 258:bootloader.c  ****     in_sysex = 1;
 1190               	.LM129:
 1191 0016 81E0      		ldi r24,lo8(1)
 1192 0018 8093 0000 		sts in_sysex,r24
 1193 001c 0895      		ret
 1194               	.L88:
 260:bootloader.c  ****   } else if (c == 0xF7) {
 1196               	.LM130:
 1197 001e 873F      		cpi r24,lo8(-9)
 1198 0020 01F4      		brne .L91
 261:bootloader.c  ****     if (in_sysex == 1) {
 1200               	.LM131:
 1201 0022 8091 0000 		lds r24,in_sysex
 1202 0026 8130      		cpi r24,lo8(1)
 1203 0028 01F4      		brne .L97
 262:bootloader.c  ****       handle_sysex();
 1205               	.LM132:
 1206 002a 0E94 0000 		call handle_sysex
 1207 002e 00C0      		rjmp .L97
 1208               	.L91:
 266:bootloader.c  ****   } else if (MIDI_IS_STATUS_BYTE(c)) {
 1210               	.LM133:
 1211 0030 87FF      		sbrs r24,7
 1212 0032 00C0      		rjmp .L93
 1213               	.L97:
 267:bootloader.c  ****     in_sysex = 0;
 1215               	.LM134:
 1216 0034 1092 0000 		sts in_sysex,__zero_reg__
 1217 0038 0895      		ret
 1218               	.L93:
 271:bootloader.c  ****   if (in_sysex) {
 1220               	.LM135:
 1221 003a 8091 0000 		lds r24,in_sysex
 1222 003e 8823      		tst r24
 1223 0040 01F0      		breq .L96
 272:bootloader.c  ****     data[sysex_cnt++] = c;
 1225               	.LM136:
 1226 0042 8091 0000 		lds r24,sysex_cnt
 1227 0046 E82F      		mov r30,r24
 1228 0048 F0E0      		ldi r31,lo8(0)
 1229 004a E050      		subi r30,lo8(-(data))
 1230 004c F040      		sbci r31,hi8(-(data))
 1231 004e 9083      		st Z,r25
 1232 0050 982F      		mov r25,r24
 1233 0052 9F5F      		subi r25,lo8(-(1))
 1234 0054 9093 0000 		sts sysex_cnt,r25
 273:bootloader.c  ****     if (sysex_cnt >= 3) {
 1236               	.LM137:
 1237 0058 9330      		cpi r25,lo8(3)
 1238 005a 00F0      		brlo .L94
 274:bootloader.c  ****       if (data[0] != SYSEX_VENDOR_1 ||
 1240               	.LM138:
 1241 005c 8091 0000 		lds r24,data
 1242 0060 8823      		tst r24
 1243 0062 01F4      		brne .L95
 1244 0064 8091 0000 		lds r24,data+1
 1245 0068 8331      		cpi r24,lo8(19)
 1246 006a 01F4      		brne .L95
 1247 006c 8091 0000 		lds r24,data+2
 1248 0070 8134      		cpi r24,lo8(65)
 1249 0072 01F0      		breq .L94
 1250               	.L95:
 277:bootloader.c  **** 	in_sysex = 0;
 1252               	.LM139:
 1253 0074 1092 0000 		sts in_sysex,__zero_reg__
 1254               	.L94:
 280:bootloader.c  ****     if (sysex_cnt > 100) {
 1256               	.LM140:
 1257 0078 9536      		cpi r25,lo8(101)
 1258 007a 00F0      		brlo .L96
 282:bootloader.c  ****       in_sysex = 0;
 1260               	.LM141:
 1261 007c 1092 0000 		sts in_sysex,__zero_reg__
 1262               	.L96:
 1263 0080 0895      		ret
 1265               	.Lscope14:
 1267               		.stabd	78,0,0
 1268               		.data
 1269               	.LC2:
 1270 0011 424F 4F54 		.string	"BOOTLOADER"
 1270      4C4F 4144 
 1270      4552 00
 1271               		.section	.text.main,"ax",@progbits
 1273               	.global	main
 1275               	main:
 1276               		.stabd	46,0,0
 289:bootloader.c  **** 
 290:bootloader.c  **** int main() {
 1278               	.LM142:
 1279               	.LFBB15:
 1280 0000 1F93      		push r17
 1281               	/* prologue: function */
 1282               	/* frame size = 0 */
 291:bootloader.c  ****   cli();
 1284               	.LM143:
 1285               	/* #APP */
 1286               	 ;  292 "bootloader.c" 1
 1287 0002 F894      		cli
 1288               	 ;  0 "" 2
 292:bootloader.c  ****   asm("wdr");
 1290               	.LM144:
 1291               	 ;  293 "bootloader.c" 1
 1292 0004 A895      		wdr
 1293               	 ;  0 "" 2
 293:bootloader.c  ****   wdt_disable();
 1295               	.LM145:
 1296               	/* #NOAPP */
 1297 0006 28E1      		ldi r18,lo8(24)
 1298               	/* #APP */
 1299               	 ;  294 "bootloader.c" 1
 1300 0008 0FB6      		in __tmp_reg__, __SREG__
 1301 000a F894      		cli
 1302 000c 21BD      		out 33, r18
 1303 000e 11BC      		out 33, __zero_reg__
 1304 0010 0FBE      		out __SREG__,__tmp_reg__
 1305               		
 1306               	 ;  0 "" 2
 294:bootloader.c  **** 
 295:bootloader.c  ****   DDRE = 0xFF;
 1308               	.LM146:
 1309               	/* #NOAPP */
 1310 0012 8FEF      		ldi r24,lo8(-1)
 1311 0014 82B9      		out 34-32,r24
 296:bootloader.c  **** 
 297:bootloader.c  ****   TCCR3B = _BV(WGM32) | _BV(CS30);
 1313               	.LM147:
 1314 0016 89E0      		ldi r24,lo8(9)
 1315 0018 8093 8A00 		sts 138,r24
 298:bootloader.c  ****   TCCR3A = _BV(WGM30) | _BV(COM3A1);
 1317               	.LM148:
 1318 001c 81E8      		ldi r24,lo8(-127)
 1319 001e 8093 8B00 		sts 139,r24
 299:bootloader.c  ****   OCR3A = 160;
 1321               	.LM149:
 1322 0022 80EA      		ldi r24,lo8(160)
 1323 0024 90E0      		ldi r25,hi8(160)
 1324 0026 9093 8700 		sts (134)+1,r25
 1325 002a 8093 8600 		sts 134,r24
 300:bootloader.c  ****   
 301:bootloader.c  ****   MCUCR = _BV(IVCE) | _BV(IVSEL);
 1327               	.LM150:
 1328 002e 83E0      		ldi r24,lo8(3)
 1329 0030 85BF      		out 85-32,r24
 302:bootloader.c  **** 
 303:bootloader.c  ****   /* init uart */
 304:bootloader.c  ****   UBRR0H = (UART_BAUDRATE_REG >> 8);
 1331               	.LM151:
 1332 0032 1092 9000 		sts 144,__zero_reg__
 305:bootloader.c  ****   UBRR0L = (UART_BAUDRATE_REG & 0xFF);
 1334               	.LM152:
 1335 0036 8FE1      		ldi r24,lo8(31)
 1336 0038 89B9      		out 41-32,r24
 306:bootloader.c  **** 
 307:bootloader.c  ****   /** 8 bit, no parity **/
 308:bootloader.c  ****   UCSR0C = (3<<UCSZ00); 
 1338               	.LM153:
 1339 003a 86E0      		ldi r24,lo8(6)
 1340 003c 8093 9500 		sts 149,r24
 309:bootloader.c  ****   UCSR0B = _BV(RXEN) | _BV(TXEN);
 1342               	.LM154:
 1343 0040 2AB9      		out 42-32,r18
 310:bootloader.c  **** 
 311:bootloader.c  ****   /* sr init */
 312:bootloader.c  ****   sr165_init();
 1345               	.LM155:
 1346 0042 0E94 0000 		call sr165_init
 313:bootloader.c  ****   
 314:bootloader.c  ****   lcd_init();
 1348               	.LM156:
 1349 0046 0E94 0000 		call lcd_init
 315:bootloader.c  ****   lcd_line1();
 1351               	.LM157:
 1352 004a 0E94 0000 		call lcd_line1
 316:bootloader.c  ****   lcd_clear_line();
 1354               	.LM158:
 1355 004e 0E94 0000 		call lcd_clear_line
 317:bootloader.c  ****   lcd_line2();
 1357               	.LM159:
 1358 0052 0E94 0000 		call lcd_line2
 318:bootloader.c  ****   lcd_clear_line();
 1360               	.LM160:
 1361 0056 0E94 0000 		call lcd_clear_line
 319:bootloader.c  ****   lcd_line1();
 1363               	.LM161:
 1364 005a 0E94 0000 		call lcd_line1
 320:bootloader.c  ****   lcd_put((uint8_t *)"BOOTLOADER", 10);
 1366               	.LM162:
 1367 005e 80E0      		ldi r24,lo8(.LC2)
 1368 0060 90E0      		ldi r25,hi8(.LC2)
 1369 0062 6AE0      		ldi r22,lo8(10)
 1370 0064 0E94 0000 		call lcd_put
 321:bootloader.c  **** 
 322:bootloader.c  ****   if (eeprom_read_word(START_MAIN_APP_ADDR) == 1 && !is_button_pressed()) {
 1372               	.LM163:
 1373 0068 84E0      		ldi r24,lo8(4)
 1374 006a 90E0      		ldi r25,hi8(4)
 1375 006c 0E94 0000 		call __eerd_word_m64
 1376 0070 0197      		sbiw r24,1
 1377 0072 01F4      		brne .L99
 1378 0074 0E94 0000 		call is_button_pressed
 1379 0078 8823      		tst r24
 1380 007a 01F4      		brne .L99
 323:bootloader.c  ****     jump_to_main_program();
 1382               	.LM164:
 1383 007c 0E94 0000 		call jump_to_main_program
 1384               	.L99:
 1385 0080 E0E0      		ldi r30,lo8(ack_msg)
 1386 0082 F0E0      		ldi r31,hi8(ack_msg)
 1387               	.L101:
 1388               	.LBB57:
 1389               	.LBB58:
  96:bootloader.c  ****     bl_uart_putc(ack_msg[i]);
 1391               	.LM165:
 1392 0084 8081      		ld r24,Z
 1393               	.L100:
 1394               	.LBB59:
 1395               	.LBB60:
  80:bootloader.c  ****   while (!UART_CHECK_EMPTY_BUFFER())
 1397               	.LM166:
 1398 0086 5D9B      		sbis 43-32,5
 1399 0088 00C0      		rjmp .L100
  82:bootloader.c  ****   UART_WRITE_CHAR(c);
 1401               	.LM167:
 1402 008a 8CB9      		out 44-32,r24
 1403 008c 3196      		adiw r30,1
 1404               	.LBE60:
 1405               	.LBE59:
  95:bootloader.c  ****   for (i = 0; i < sizeof(ack_msg); i++)
 1407               	.LM168:
 1408 008e 80E0      		ldi r24,hi8(ack_msg+6)
 1409 0090 E030      		cpi r30,lo8(ack_msg+6)
 1410 0092 F807      		cpc r31,r24
 1411 0094 01F4      		brne .L101
 1412 0096 10E0      		ldi r17,lo8(0)
 1413               	.L113:
 1414               	.LBE58:
 1415               	.LBE57:
 324:bootloader.c  ****   }
 325:bootloader.c  **** 
 326:bootloader.c  ****   midi_sysex_send_ack();
 327:bootloader.c  **** 
 328:bootloader.c  ****   uint8_t button = 0;
 329:bootloader.c  ****   for (;;) {
 330:bootloader.c  ****     if (!is_button_pressed()) {
 1417               	.LM169:
 1418 0098 0E94 0000 		call is_button_pressed
 1419 009c 8823      		tst r24
 1420 009e 01F4      		brne .L102
 1421 00a0 11E0      		ldi r17,lo8(1)
 1422 00a2 00C0      		rjmp .L103
 1423               	.L102:
 331:bootloader.c  ****       button = 1;
 332:bootloader.c  ****     } else {
 333:bootloader.c  ****       if (button) {
 1425               	.LM170:
 1426 00a4 1123      		tst r17
 1427 00a6 01F0      		breq .L103
 334:bootloader.c  **** 	jump_to_main_program();
 1429               	.LM171:
 1430 00a8 0E94 0000 		call jump_to_main_program
 1431               	.L103:
 335:bootloader.c  ****       }
 336:bootloader.c  ****     }
 337:bootloader.c  **** 
 338:bootloader.c  ****     if (UART_CHECK_RX()) {
 1433               	.LM172:
 1434 00ac 5F9B      		sbis 43-32,7
 1435 00ae 00C0      		rjmp .L113
 1436               	.L108:
 1437               	.LBB61:
 1438               	.LBB62:
 1439               	.LBB63:
  74:bootloader.c  ****   while (!UART_CHECK_RX())
 1441               	.LM173:
 1442 00b0 5F9B      		sbis 43-32,7
 1443 00b2 00C0      		rjmp .L108
  76:bootloader.c  ****   return UART_READ_CHAR();
 1445               	.LM174:
 1446 00b4 8CB1      		in r24,44-32
 1447               	.LBE63:
 1448               	.LBE62:
 339:bootloader.c  ****       uint8_t c = bl_uart_getc();
 340:bootloader.c  ****       handle_midi(c);
 1450               	.LM175:
 1451 00b6 0E94 0000 		call handle_midi
 1452 00ba 00C0      		rjmp .L113
 1453               	.LBE61:
 1461               	.Lscope15:
 1463               		.stabd	78,0,0
 1464               	.global	jump_to_app
 1465               	.global	jump_to_app
 1466               		.section .bss
 1469               	jump_to_app:
 1470 0000 0000      		.skip 2,0
 1471               	.global	ack_msg
 1472               		.data
 1475               	ack_msg:
 1476 001c F0        		.byte	-16
 1477 001d 00        		.byte	0
 1478 001e 13        		.byte	19
 1479 001f 41        		.byte	65
 1480 0020 02        		.byte	2
 1481 0021 F7        		.byte	-9
 1482               	.global	nak_msg
 1485               	nak_msg:
 1486 0022 F0        		.byte	-16
 1487 0023 00        		.byte	0
 1488 0024 13        		.byte	19
 1489 0025 41        		.byte	65
 1490 0026 10        		.byte	16
 1491 0027 F7        		.byte	-9
 1492               	.global	block_cnt
 1493               	.global	block_cnt
 1494               		.section .bss
 1497               	block_cnt:
 1498 0002 0000      		.skip 2,0
 1499               	.global	in_sysex
 1500               	.global	in_sysex
 1503               	in_sysex:
 1504 0004 00        		.skip 1,0
 1505               		.lcomm recvd,2
 1506               		.lcomm sysex_address,2
 1507               		.comm sysex_data,256,1
 1508               		.comm data,100,1
 1509               		.comm sysex_cnt,1,1
 1520               		.text
 1522               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 bootloader.c
     /tmp/cc0JPX8G.s:2      *ABS*:000000000000003f __SREG__
     /tmp/cc0JPX8G.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/cc0JPX8G.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/cc0JPX8G.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/cc0JPX8G.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc0JPX8G.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc0JPX8G.s:119    .text.bl_uart_getc:0000000000000000 bl_uart_getc
     /tmp/cc0JPX8G.s:147    .text.bl_uart_putc:0000000000000000 bl_uart_putc
     /tmp/cc0JPX8G.s:174    .text.midi_sysex_send_ack:0000000000000000 midi_sysex_send_ack
     /tmp/cc0JPX8G.s:1475   .data:000000000000001c ack_msg
     /tmp/cc0JPX8G.s:220    .text.midi_sysex_send_nak:0000000000000000 midi_sysex_send_nak
     /tmp/cc0JPX8G.s:1485   .data:0000000000000022 nak_msg
     /tmp/cc0JPX8G.s:268    .text.make_word:0000000000000000 make_word
                            *COM*:0000000000000064 data
     /tmp/cc0JPX8G.s:335    .text.check_firmware_checksum:0000000000000000 check_firmware_checksum
     /tmp/cc0JPX8G.s:410    .text.is_button_pressed:0000000000000000 is_button_pressed
     /tmp/cc0JPX8G.s:439    .text.write_block_data:0000000000000000 write_block_data
     /tmp/cc0JPX8G.s:1505   .bss:0000000000000007 sysex_address
                            *COM*:0000000000000100 sysex_data
                             .bss:0000000000000005 recvd
     /tmp/cc0JPX8G.s:580    .text.write_block:0000000000000000 write_block
                            *COM*:0000000000000001 sysex_cnt
     /tmp/cc0JPX8G.s:796    .text.jump_to_main_program:0000000000000000 jump_to_main_program
     /tmp/cc0JPX8G.s:1469   .bss:0000000000000000 jump_to_app
     /tmp/cc0JPX8G.s:918    .text.write_firmware_checksum:0000000000000000 write_firmware_checksum
     /tmp/cc0JPX8G.s:962    .text.write_checksum:0000000000000000 write_checksum
     /tmp/cc0JPX8G.s:1040   .text.handle_sysex:0000000000000000 handle_sysex
     /tmp/cc0JPX8G.s:1165   .text.handle_midi:0000000000000000 handle_midi
     /tmp/cc0JPX8G.s:1503   .bss:0000000000000004 in_sysex
     /tmp/cc0JPX8G.s:1275   .text.main:0000000000000000 main
     /tmp/cc0JPX8G.s:1497   .bss:0000000000000002 block_cnt

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__eerd_word_m64
sr165_read
lcd_line2
lcd_put
lcd_putnumberx
__epilogue_restores__
lcd_line1
lcd_clear_line
__eewr_word_m64
sr165_init
lcd_init
