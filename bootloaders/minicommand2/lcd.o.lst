   1               		.file	"lcd.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__  = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.global __do_copy_data
   9               		.global __do_clear_bss
  12               		.text
  13               	.Ltext0:
  89               		.section	.text.lcd_enable,"ax",@progbits
  91               	.global	lcd_enable
  93               	lcd_enable:
  94               		.stabd	46,0,0
   0:lcd.c         **** #include "app.h"
   1:lcd.c         **** #include "common.h"
   2:lcd.c         **** 
   3:lcd.c         **** #include <avr/pgmspace.h>
   4:lcd.c         **** #include <util/delay.h>
   5:lcd.c         **** #include <avr/io.h>
   6:lcd.c         **** #include <avr/interrupt.h>
   7:lcd.c         **** #include "lcd.h"
   8:lcd.c         **** 
   9:lcd.c         **** #define LCD_DATA_PORT PORTF
  10:lcd.c         **** #define LCD_DATA_DDR  DDRF
  11:lcd.c         **** 
  12:lcd.c         **** #define LCD_CTRL_PORT PORTE
  13:lcd.c         **** #define LCD_CTRL_DDR  DDRE
  14:lcd.c         **** 
  15:lcd.c         **** #define LCD_DELAY_US 50
  16:lcd.c         **** 
  17:lcd.c         **** #define LCD_RS     PE2
  18:lcd.c         **** #define LCD_ENABLE PE6
  19:lcd.c         **** 
  20:lcd.c         **** #define LCD_SET_ENABLE()   { SET_BIT8(LCD_CTRL_PORT, LCD_ENABLE); }
  21:lcd.c         **** #define LCD_CLEAR_ENABLE() { CLEAR_BIT8(LCD_CTRL_PORT, LCD_ENABLE); }
  22:lcd.c         **** #define LCD_SET_RS()       { SET_BIT8(LCD_CTRL_PORT, LCD_RS); }
  23:lcd.c         **** #define LCD_CLEAR_RS()     { CLEAR_BIT8(LCD_CTRL_PORT, LCD_RS); }
  24:lcd.c         **** 
  25:lcd.c         **** void inline lcd_enable(void) {
  96               	.LM0:
  97               	.LFBB1:
  98               	/* prologue: function */
  99               	/* frame size = 0 */
  26:lcd.c         ****   LCD_SET_ENABLE();
 101               	.LM1:
 102 0000 1E9A      		sbi 35-32,6
  27:lcd.c         ****   //  _delay_us(1);
  28:lcd.c         ****   //  asm("nop");
  29:lcd.c         ****   //  asm("nop");
  30:lcd.c         ****   LCD_CLEAR_ENABLE();
 104               	.LM2:
 105 0002 1E98      		cbi 35-32,6
 106               	/* epilogue start */
  31:lcd.c         **** }
 108               	.LM3:
 109 0004 0895      		ret
 111               	.Lscope1:
 113               		.stabd	78,0,0
 114               		.section	.text.lcd_putnibble,"ax",@progbits
 117               	.global	lcd_putnibble
 119               	lcd_putnibble:
 120               		.stabd	46,0,0
  32:lcd.c         **** 
  33:lcd.c         **** void lcd_putnibble(uint8_t nibble) {
 122               	.LM4:
 123               	.LFBB2:
 124               	/* prologue: function */
 125               	/* frame size = 0 */
  34:lcd.c         ****   uint8_t tmp = SREG;
 127               	.LM5:
 128 0000 2FB7      		in r18,__SREG__
  35:lcd.c         ****   cli();
 130               	.LM6:
 131               	/* #APP */
 132               	 ;  36 "lcd.c" 1
 133 0002 F894      		cli
 134               	 ;  0 "" 2
  36:lcd.c         ****   LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0xF);
 136               	.LM7:
 137               	/* #NOAPP */
 138 0004 E2E6      		ldi r30,lo8(98)
 139 0006 F0E0      		ldi r31,hi8(98)
 140 0008 9081      		ld r25,Z
 141 000a 8F70      		andi r24,lo8(15)
 142 000c 907F      		andi r25,lo8(-16)
 143 000e 982B      		or r25,r24
 144 0010 9083      		st Z,r25
 145               	.LBB84:
 146               	.LBB85:
  27:lcd.c         ****   LCD_SET_ENABLE();
 148               	.LM8:
 149 0012 1E9A      		sbi 35-32,6
  31:lcd.c         ****   LCD_CLEAR_ENABLE();
 151               	.LM9:
 152 0014 1E98      		cbi 35-32,6
 153               	.LBE85:
 154               	.LBE84:
  37:lcd.c         ****   lcd_enable();
  38:lcd.c         ****   SREG = tmp;
 156               	.LM10:
 157 0016 2FBF      		out __SREG__,r18
 158               	/* epilogue start */
  39:lcd.c         **** }
 160               	.LM11:
 161 0018 0895      		ret
 166               	.Lscope2:
 168               		.stabd	78,0,0
 169               		.section	.text.lcd_putbyte,"ax",@progbits
 172               	.global	lcd_putbyte
 174               	lcd_putbyte:
 175               		.stabd	46,0,0
  40:lcd.c         **** 
  41:lcd.c         **** void lcd_putbyte(uint8_t byte) {
 177               	.LM12:
 178               	.LFBB3:
 179               	/* prologue: function */
 180               	/* frame size = 0 */
 181               	.LBB86:
 182               	.LBB87:
  35:lcd.c         ****   uint8_t tmp = SREG;
 184               	.LM13:
 185 0000 3FB7      		in r19,__SREG__
  36:lcd.c         ****   cli();
 187               	.LM14:
 188               	/* #APP */
 189               	 ;  36 "lcd.c" 1
 190 0002 F894      		cli
 191               	 ;  0 "" 2
  37:lcd.c         ****   LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0xF);
 193               	.LM15:
 194               	/* #NOAPP */
 195 0004 E2E6      		ldi r30,lo8(98)
 196 0006 F0E0      		ldi r31,hi8(98)
 197 0008 9081      		ld r25,Z
 198 000a 282F      		mov r18,r24
 199 000c 2295      		swap r18
 200 000e 2F70      		andi r18,0x0f
 201 0010 907F      		andi r25,lo8(-16)
 202 0012 292B      		or r18,r25
 203 0014 2083      		st Z,r18
 204               	.LBB88:
 205               	.LBB89:
  27:lcd.c         ****   LCD_SET_ENABLE();
 207               	.LM16:
 208 0016 1E9A      		sbi 35-32,6
  31:lcd.c         ****   LCD_CLEAR_ENABLE();
 210               	.LM17:
 211 0018 1E98      		cbi 35-32,6
 212               	.LBE89:
 213               	.LBE88:
  39:lcd.c         ****   SREG = tmp;
 215               	.LM18:
 216 001a 3FBF      		out __SREG__,r19
 217               	.LBE87:
 218               	.LBE86:
 219               	.LBB90:
 220               	.LBB91:
  35:lcd.c         ****   uint8_t tmp = SREG;
 222               	.LM19:
 223 001c 2FB7      		in r18,__SREG__
  36:lcd.c         ****   cli();
 225               	.LM20:
 226               	/* #APP */
 227               	 ;  36 "lcd.c" 1
 228 001e F894      		cli
 229               	 ;  0 "" 2
  37:lcd.c         ****   LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0xF);
 231               	.LM21:
 232               	/* #NOAPP */
 233 0020 E2E6      		ldi r30,lo8(98)
 234 0022 F0E0      		ldi r31,hi8(98)
 235 0024 9081      		ld r25,Z
 236 0026 8F70      		andi r24,lo8(15)
 237 0028 907F      		andi r25,lo8(-16)
 238 002a 982B      		or r25,r24
 239 002c 9083      		st Z,r25
 240               	.LBB92:
 241               	.LBB93:
  27:lcd.c         ****   LCD_SET_ENABLE();
 243               	.LM22:
 244 002e 1E9A      		sbi 35-32,6
  31:lcd.c         ****   LCD_CLEAR_ENABLE();
 246               	.LM23:
 247 0030 1E98      		cbi 35-32,6
 248               	.LBE93:
 249               	.LBE92:
  39:lcd.c         ****   SREG = tmp;
 251               	.LM24:
 252 0032 2FBF      		out __SREG__,r18
 253               	/* epilogue start */
 254               	.LBE91:
 255               	.LBE90:
  42:lcd.c         ****   lcd_putnibble(byte >> 4);
  43:lcd.c         ****   lcd_putnibble(byte & 0xF);
  44:lcd.c         **** }
 257               	.LM25:
 258 0034 0895      		ret
 260               	.Lscope3:
 262               		.stabd	78,0,0
 263               		.section	.text.lcd_command,"ax",@progbits
 266               	.global	lcd_command
 268               	lcd_command:
 269               		.stabd	46,0,0
  45:lcd.c         **** 
  46:lcd.c         **** void lcd_command(uint8_t command) {
 271               	.LM26:
 272               	.LFBB4:
 273               	/* prologue: function */
 274               	/* frame size = 0 */
  47:lcd.c         ****   LCD_CLEAR_RS();
 276               	.LM27:
 277 0000 1A98      		cbi 35-32,2
  48:lcd.c         **** 
  49:lcd.c         ****   lcd_putbyte(command);
 279               	.LM28:
 280 0002 0E94 0000 		call lcd_putbyte
 281               	.LBB94:
 282               	.LBB95:
 283               	.LBB96:
 284               	.LBB97:
 285               	.LBB98:
 286               	.LBB99:
 288               	.Ltext1:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    All rights reserved.
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      distribution.
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /* $Id: delay_basic.h,v 1.1 2007/05/13 21:23:20 joerg_wunsch Exp $ */
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #include <inttypes.h>
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \file */
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \code
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     \endcode
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     to the overall delay time.
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_1(uint8_t __count) __attribute__((always_inline));
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** static inline void _delay_loop_2(uint16_t __count) __attribute__((always_inline));
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** #endif
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     register.
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     can be achieved.
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** */
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		"brne 1b"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "=r" (__count)
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 		: "0" (__count)
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	);
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** }
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     counter register pair.
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h ****  */
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** void
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** {
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 290               	.LM29:
 291 0006 88EC      		ldi r24,lo8(200)
 292 0008 90E0      		ldi r25,hi8(200)
 293               	/* #APP */
 294               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 295 000a 0197      		1: sbiw r24,1
 296 000c 01F4      		brne 1b
 297               	 ;  0 "" 2
 298               	/* epilogue start */
 299               	/* #NOAPP */
 300               	.LBE99:
 301               	.LBE98:
 302               	.LBE97:
 303               	.LBE96:
 304               	.LBE95:
 305               	.LBE94:
 307               	.Ltext2:
  50:lcd.c         ****   _delay_us(LCD_DELAY_US);
  51:lcd.c         **** }
 309               	.LM30:
 310 000e 0895      		ret
 312               	.Lscope4:
 314               		.stabd	78,0,0
 315               		.section	.text.lcd_data,"ax",@progbits
 318               	.global	lcd_data
 320               	lcd_data:
 321               		.stabd	46,0,0
  52:lcd.c         **** 
  53:lcd.c         **** void lcd_data(uint8_t data) {
 323               	.LM31:
 324               	.LFBB5:
 325               	/* prologue: function */
 326               	/* frame size = 0 */
  54:lcd.c         ****   LCD_SET_RS();
 328               	.LM32:
 329 0000 1A9A      		sbi 35-32,2
  55:lcd.c         ****   lcd_putbyte(data);
 331               	.LM33:
 332 0002 0E94 0000 		call lcd_putbyte
 333               	.LBB100:
 334               	.LBB101:
 335               	.LBB102:
 336               	.LBB103:
 337               	.LBB104:
 338               	.LBB105:
 340               	.Ltext3:
 342               	.LM34:
 343 0006 88EC      		ldi r24,lo8(200)
 344 0008 90E0      		ldi r25,hi8(200)
 345               	/* #APP */
 346               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 347 000a 0197      		1: sbiw r24,1
 348 000c 01F4      		brne 1b
 349               	 ;  0 "" 2
 350               	/* epilogue start */
 351               	/* #NOAPP */
 352               	.LBE105:
 353               	.LBE104:
 354               	.LBE103:
 355               	.LBE102:
 356               	.LBE101:
 357               	.LBE100:
 359               	.Ltext4:
  56:lcd.c         ****   _delay_us(LCD_DELAY_US);
  57:lcd.c         **** }
 361               	.LM35:
 362 000e 0895      		ret
 364               	.Lscope5:
 366               		.stabd	78,0,0
 367               		.section	.text.lcd_putnumber,"ax",@progbits
 370               	.global	lcd_putnumber
 372               	lcd_putnumber:
 373               		.stabd	46,0,0
  58:lcd.c         **** 
  59:lcd.c         **** void lcd_putnumber(uint8_t num) {
 375               	.LM36:
 376               	.LFBB6:
 377 0000 1F93      		push r17
 378               	/* prologue: function */
 379               	/* frame size = 0 */
 380 0002 182F      		mov r17,r24
  60:lcd.c         ****   lcd_data(num / 100 + '0');
 382               	.LM37:
 383 0004 64E6      		ldi r22,lo8(100)
 384 0006 0E94 0000 		call __udivmodqi4
 385 000a 805D      		subi r24,lo8(-(48))
 386 000c 0E94 0000 		call lcd_data
  61:lcd.c         ****   lcd_data((num % 100) / 10 + '0');
 388               	.LM38:
 389 0010 812F      		mov r24,r17
 390 0012 64E6      		ldi r22,lo8(100)
 391 0014 0E94 0000 		call __udivmodqi4
 392 0018 892F      		mov r24,r25
 393 001a 6AE0      		ldi r22,lo8(10)
 394 001c 0E94 0000 		call __udivmodqi4
 395 0020 805D      		subi r24,lo8(-(48))
 396 0022 0E94 0000 		call lcd_data
  62:lcd.c         ****   lcd_data((num % 10) + '0');
 398               	.LM39:
 399 0026 812F      		mov r24,r17
 400 0028 6AE0      		ldi r22,lo8(10)
 401 002a 0E94 0000 		call __udivmodqi4
 402 002e 892F      		mov r24,r25
 403 0030 805D      		subi r24,lo8(-(48))
 404 0032 0E94 0000 		call lcd_data
 405               	/* epilogue start */
  63:lcd.c         **** }
 407               	.LM40:
 408 0036 1F91      		pop r17
 409 0038 0895      		ret
 411               	.Lscope6:
 413               		.stabd	78,0,0
 414               		.section	.text.lcd_putnumber16,"ax",@progbits
 417               	.global	lcd_putnumber16
 419               	lcd_putnumber16:
 420               		.stabd	46,0,0
  64:lcd.c         **** 
  65:lcd.c         **** void lcd_putnumber16(uint16_t num) {
 422               	.LM41:
 423               	.LFBB7:
 424 0000 0F93      		push r16
 425 0002 1F93      		push r17
 426               	/* prologue: function */
 427               	/* frame size = 0 */
 428 0004 8C01      		movw r16,r24
  66:lcd.c         ****   lcd_data(num / 10000 + '0');
 430               	.LM42:
 431 0006 60E1      		ldi r22,lo8(10000)
 432 0008 77E2      		ldi r23,hi8(10000)
 433 000a 0E94 0000 		call __udivmodhi4
 434 000e 862F      		mov r24,r22
 435 0010 805D      		subi r24,lo8(-(48))
 436 0012 0E94 0000 		call lcd_data
  67:lcd.c         ****   lcd_data((num % 10000) / 1000 + '0');
 438               	.LM43:
 439 0016 C801      		movw r24,r16
 440 0018 60E1      		ldi r22,lo8(10000)
 441 001a 77E2      		ldi r23,hi8(10000)
 442 001c 0E94 0000 		call __udivmodhi4
 443 0020 68EE      		ldi r22,lo8(1000)
 444 0022 73E0      		ldi r23,hi8(1000)
 445 0024 0E94 0000 		call __udivmodhi4
 446 0028 862F      		mov r24,r22
 447 002a 805D      		subi r24,lo8(-(48))
 448 002c 0E94 0000 		call lcd_data
  68:lcd.c         ****   lcd_data((num % 1000) / 100 + '0');
 450               	.LM44:
 451 0030 C801      		movw r24,r16
 452 0032 68EE      		ldi r22,lo8(1000)
 453 0034 73E0      		ldi r23,hi8(1000)
 454 0036 0E94 0000 		call __udivmodhi4
 455 003a 64E6      		ldi r22,lo8(100)
 456 003c 70E0      		ldi r23,hi8(100)
 457 003e 0E94 0000 		call __udivmodhi4
 458 0042 862F      		mov r24,r22
 459 0044 805D      		subi r24,lo8(-(48))
 460 0046 0E94 0000 		call lcd_data
  69:lcd.c         ****   lcd_data((num % 100) / 10 + '0');
 462               	.LM45:
 463 004a C801      		movw r24,r16
 464 004c 64E6      		ldi r22,lo8(100)
 465 004e 70E0      		ldi r23,hi8(100)
 466 0050 0E94 0000 		call __udivmodhi4
 467 0054 6AE0      		ldi r22,lo8(10)
 468 0056 70E0      		ldi r23,hi8(10)
 469 0058 0E94 0000 		call __udivmodhi4
 470 005c 862F      		mov r24,r22
 471 005e 805D      		subi r24,lo8(-(48))
 472 0060 0E94 0000 		call lcd_data
  70:lcd.c         ****   lcd_data((num % 10) + '0');
 474               	.LM46:
 475 0064 C801      		movw r24,r16
 476 0066 6AE0      		ldi r22,lo8(10)
 477 0068 70E0      		ldi r23,hi8(10)
 478 006a 0E94 0000 		call __udivmodhi4
 479 006e 805D      		subi r24,lo8(-(48))
 480 0070 0E94 0000 		call lcd_data
 481               	/* epilogue start */
  71:lcd.c         **** }
 483               	.LM47:
 484 0074 1F91      		pop r17
 485 0076 0F91      		pop r16
 486 0078 0895      		ret
 488               	.Lscope7:
 490               		.stabd	78,0,0
 491               		.section	.text.lcd_putnumber32,"ax",@progbits
 493               	.global	lcd_putnumber32
 495               	lcd_putnumber32:
 496               		.stabd	46,0,0
  72:lcd.c         **** 
  73:lcd.c         **** void lcd_putnumber32(uint32_t num) {
 498               	.LM48:
 499               	.LFBB8:
 500 0000 AAE0      		ldi r26,lo8(10)
 501 0002 B0E0      		ldi r27,hi8(10)
 502 0004 E0E0      		ldi r30,lo8(gs(1f))
 503 0006 F0E0      		ldi r31,hi8(gs(1f))
 504 0008 0C94 0000 		jmp __prologue_saves__+((18 - 10) * 2)
 505               	1:
 506               	/* prologue: function */
 507               	/* frame size = 10 */
 508 000c 6B01      		movw r12,r22
 509 000e 7C01      		movw r14,r24
 511               	.LM49:
 512 0010 8E01      		movw r16,r28
 513 0012 0F5F      		subi r16,lo8(-(1))
 514 0014 1F4F      		sbci r17,hi8(-(1))
  74:lcd.c         ****   uint8_t res[10];
  75:lcd.c         ****   uint8_t i;
  76:lcd.c         ****   for (i = 0; i < 10; i++) {
 516               	.LM50:
 517 0016 8BE0      		ldi r24,lo8(11)
 518 0018 A82E      		mov r10,r24
 519 001a B12C      		mov r11,__zero_reg__
 520 001c AC0E      		add r10,r28
 521 001e BD1E      		adc r11,r29
 522               	.L16:
  77:lcd.c         ****     res[i] = num % 10;
 524               	.LM51:
 525 0020 B601      		movw r22,r12
 526 0022 C701      		movw r24,r14
 527 0024 2AE0      		ldi r18,lo8(10)
 528 0026 30E0      		ldi r19,hi8(10)
 529 0028 40E0      		ldi r20,hlo8(10)
 530 002a 50E0      		ldi r21,hhi8(10)
 531 002c 0E94 0000 		call __udivmodsi4
 532 0030 F801      		movw r30,r16
 533 0032 6193      		st Z+,r22
 534 0034 8F01      		movw r16,r30
  78:lcd.c         ****     num /= 10;
 536               	.LM52:
 537 0036 B601      		movw r22,r12
 538 0038 C701      		movw r24,r14
 539 003a 2AE0      		ldi r18,lo8(10)
 540 003c 30E0      		ldi r19,hi8(10)
 541 003e 40E0      		ldi r20,hlo8(10)
 542 0040 50E0      		ldi r21,hhi8(10)
 543 0042 0E94 0000 		call __udivmodsi4
 544 0046 6901      		movw r12,r18
 545 0048 7A01      		movw r14,r20
  77:lcd.c         ****     res[i] = num % 10;
 547               	.LM53:
 548 004a 0A15      		cp r16,r10
 549 004c 1B05      		cpc r17,r11
 550 004e 01F4      		brne .L16
 551 0050 8E01      		movw r16,r28
 552 0052 065F      		subi r16,lo8(-(10))
 553 0054 1F4F      		sbci r17,hi8(-(10))
 554               	.L17:
  79:lcd.c         ****   }
  80:lcd.c         ****   for (i = 0; i < 10; i++) {
  81:lcd.c         ****     lcd_data(res[9-i]);
 556               	.LM54:
 557 0056 F801      		movw r30,r16
 558 0058 8081      		ld r24,Z
 559 005a 0E94 0000 		call lcd_data
 560 005e 0150      		subi r16,lo8(-(-1))
 561 0060 1040      		sbci r17,hi8(-(-1))
  81:lcd.c         ****     lcd_data(res[9-i]);
 563               	.LM55:
 564 0062 0C17      		cp r16,r28
 565 0064 1D07      		cpc r17,r29
 566 0066 01F4      		brne .L17
 567               	/* epilogue start */
  82:lcd.c         ****   }
  83:lcd.c         **** }
 569               	.LM56:
 570 0068 2A96      		adiw r28,10
 571 006a EAE0      		ldi r30, lo8(10)
 572 006c 0C94 0000 		jmp __epilogue_restores__ + ((18 - 10) * 2)
 577               	.Lscope8:
 579               		.stabd	78,0,0
 580               		.section	.text.lcd_putcx,"ax",@progbits
 583               	.global	lcd_putcx
 585               	lcd_putcx:
 586               		.stabd	46,0,0
  84:lcd.c         **** 
  85:lcd.c         **** void lcd_putcx(uint8_t i) {
 588               	.LM57:
 589               	.LFBB9:
 590               	/* prologue: function */
 591               	/* frame size = 0 */
  86:lcd.c         ****   if (i < 10) {
 593               	.LM58:
 594 0000 8A30      		cpi r24,lo8(10)
 595 0002 00F4      		brsh .L22
  87:lcd.c         ****     lcd_data(i + '0');
 597               	.LM59:
 598 0004 805D      		subi r24,lo8(-(48))
 599 0006 00C0      		rjmp .L25
 600               	.L22:
  88:lcd.c         ****   } else {
  89:lcd.c         ****     lcd_data(i - 10 + 'a');
 602               	.LM60:
 603 0008 895A      		subi r24,lo8(-(87))
 604               	.L25:
 605 000a 0E94 0000 		call lcd_data
 606 000e 0895      		ret
 608               	.Lscope9:
 610               		.stabd	78,0,0
 611               		.section	.text.lcd_putnumberx,"ax",@progbits
 614               	.global	lcd_putnumberx
 616               	lcd_putnumberx:
 617               		.stabd	46,0,0
  90:lcd.c         ****   }
  91:lcd.c         **** }
  92:lcd.c         **** void lcd_putnumberx(uint8_t num) {
 619               	.LM61:
 620               	.LFBB10:
 621 0000 1F93      		push r17
 622               	/* prologue: function */
 623               	/* frame size = 0 */
 624 0002 182F      		mov r17,r24
  93:lcd.c         ****   lcd_putcx((num >> 4) & 0xF);
 626               	.LM62:
 627 0004 8295      		swap r24
 628 0006 8F70      		andi r24,0x0f
 629 0008 0E94 0000 		call lcd_putcx
  94:lcd.c         ****   lcd_putcx(num & 0xF);
 631               	.LM63:
 632 000c 812F      		mov r24,r17
 633 000e 8F70      		andi r24,lo8(15)
 634 0010 0E94 0000 		call lcd_putcx
 635               	/* epilogue start */
  95:lcd.c         **** }
 637               	.LM64:
 638 0014 1F91      		pop r17
 639 0016 0895      		ret
 641               	.Lscope10:
 643               		.stabd	78,0,0
 644               		.section	.text.lcd_putnumberx16,"ax",@progbits
 647               	.global	lcd_putnumberx16
 649               	lcd_putnumberx16:
 650               		.stabd	46,0,0
  96:lcd.c         **** 
  97:lcd.c         **** void lcd_putnumberx16(uint16_t num) {
 652               	.LM65:
 653               	.LFBB11:
 654 0000 0F93      		push r16
 655 0002 1F93      		push r17
 656               	/* prologue: function */
 657               	/* frame size = 0 */
 658 0004 8C01      		movw r16,r24
  98:lcd.c         ****   lcd_putcx((num >> 12) & 0xF);
 660               	.LM66:
 661 0006 812F      		mov r24,r17
 662 0008 8295      		swap r24
 663 000a 8F70      		andi r24,0x0f
 664 000c 0E94 0000 		call lcd_putcx
  99:lcd.c         ****   lcd_putcx((num >> 8) & 0xF);
 666               	.LM67:
 667 0010 812F      		mov r24,r17
 668 0012 8F70      		andi r24,lo8(15)
 669 0014 0E94 0000 		call lcd_putcx
 100:lcd.c         ****   lcd_putcx((num >> 4) & 0xF);
 671               	.LM68:
 672 0018 C801      		movw r24,r16
 673 001a 24E0      		ldi r18,4
 674 001c 9695      	1:	lsr r25
 675 001e 8795      		ror r24
 676 0020 2A95      		dec r18
 677 0022 01F4      		brne 1b
 678 0024 8F70      		andi r24,lo8(15)
 679 0026 0E94 0000 		call lcd_putcx
 101:lcd.c         ****   lcd_putcx(num & 0xF);
 681               	.LM69:
 682 002a 802F      		mov r24,r16
 683 002c 8F70      		andi r24,lo8(15)
 684 002e 0E94 0000 		call lcd_putcx
 685               	/* epilogue start */
 102:lcd.c         **** }
 687               	.LM70:
 688 0032 1F91      		pop r17
 689 0034 0F91      		pop r16
 690 0036 0895      		ret
 692               	.Lscope11:
 694               		.stabd	78,0,0
 695               		.section	.text.lcd_puts,"ax",@progbits
 698               	.global	lcd_puts
 700               	lcd_puts:
 701               		.stabd	46,0,0
 103:lcd.c         **** 
 104:lcd.c         **** 
 105:lcd.c         **** void lcd_puts(char *s) {
 703               	.LM71:
 704               	.LFBB12:
 705 0000 CF93      		push r28
 706 0002 DF93      		push r29
 707               	/* prologue: function */
 708               	/* frame size = 0 */
 709 0004 EC01      		movw r28,r24
 710 0006 00C0      		rjmp .L31
 711               	.L32:
 106:lcd.c         ****   while (*s != 0) {
 107:lcd.c         ****     lcd_data(*s);
 713               	.LM72:
 714 0008 0E94 0000 		call lcd_data
 108:lcd.c         ****     s++;
 716               	.LM73:
 717 000c 2196      		adiw r28,1
 718               	.L31:
 107:lcd.c         ****   while (*s != 0) {
 720               	.LM74:
 721 000e 8881      		ld r24,Y
 722 0010 8823      		tst r24
 723 0012 01F4      		brne .L32
 724               	/* epilogue start */
 109:lcd.c         ****   }
 110:lcd.c         **** }
 726               	.LM75:
 727 0014 DF91      		pop r29
 728 0016 CF91      		pop r28
 729 0018 0895      		ret
 731               	.Lscope12:
 733               		.stabd	78,0,0
 734               		.section	.text.lcd_puts_fill,"ax",@progbits
 738               	.global	lcd_puts_fill
 740               	lcd_puts_fill:
 741               		.stabd	46,0,0
 111:lcd.c         **** 
 112:lcd.c         **** void lcd_puts_fill(char *s, uint8_t i) {
 743               	.LM76:
 744               	.LFBB13:
 745 0000 1F93      		push r17
 746 0002 CF93      		push r28
 747 0004 DF93      		push r29
 748               	/* prologue: function */
 749               	/* frame size = 0 */
 750 0006 EC01      		movw r28,r24
 751 0008 162F      		mov r17,r22
 752 000a 00C0      		rjmp .L35
 753               	.L36:
 113:lcd.c         ****   while (*s != 0) {
 114:lcd.c         ****     lcd_data(*s);
 755               	.LM77:
 756 000c 0E94 0000 		call lcd_data
 115:lcd.c         ****     s++;
 758               	.LM78:
 759 0010 2196      		adiw r28,1
 116:lcd.c         ****     i--;
 761               	.LM79:
 762 0012 1150      		subi r17,lo8(-(-1))
 763               	.L35:
 114:lcd.c         ****   while (*s != 0) {
 765               	.LM80:
 766 0014 8881      		ld r24,Y
 767 0016 8823      		tst r24
 768 0018 01F4      		brne .L36
 769 001a 00C0      		rjmp .L40
 770               	.L38:
 117:lcd.c         ****   }
 118:lcd.c         ****   while (i--) {
 119:lcd.c         ****     lcd_data(' ');
 772               	.LM81:
 773 001c 80E2      		ldi r24,lo8(32)
 774 001e 0E94 0000 		call lcd_data
 775 0022 1150      		subi r17,lo8(-(-1))
 776               	.L40:
 119:lcd.c         ****     lcd_data(' ');
 778               	.LM82:
 779 0024 1123      		tst r17
 780 0026 01F4      		brne .L38
 781               	/* epilogue start */
 120:lcd.c         ****   }
 121:lcd.c         **** }
 783               	.LM83:
 784 0028 DF91      		pop r29
 785 002a CF91      		pop r28
 786 002c 1F91      		pop r17
 787 002e 0895      		ret
 789               	.Lscope13:
 791               		.stabd	78,0,0
 792               		.section	.text.lcd_puts_p,"ax",@progbits
 795               	.global	lcd_puts_p
 797               	lcd_puts_p:
 798               		.stabd	46,0,0
 122:lcd.c         **** 
 123:lcd.c         **** void lcd_puts_p(PGM_P s) {
 800               	.LM84:
 801               	.LFBB14:
 802 0000 CF93      		push r28
 803 0002 DF93      		push r29
 804               	/* prologue: function */
 805               	/* frame size = 0 */
 806 0004 EC01      		movw r28,r24
 807 0006 00C0      		rjmp .L42
 808               	.L43:
 124:lcd.c         ****   char c;
 125:lcd.c         ****   while ((c = pgm_read_byte(s)) != 0) {
 126:lcd.c         ****     lcd_data(c);
 810               	.LM85:
 811 0008 0E94 0000 		call lcd_data
 127:lcd.c         ****     s++;
 813               	.LM86:
 814 000c 2196      		adiw r28,1
 815               	.L42:
 816               	.LBB106:
 126:lcd.c         ****   while ((c = pgm_read_byte(s)) != 0) {
 818               	.LM87:
 819 000e FE01      		movw r30,r28
 820               	/* #APP */
 821               	 ;  126 "lcd.c" 1
 822 0010 8491      		lpm r24, Z
 823               		
 824               	 ;  0 "" 2
 825               	/* #NOAPP */
 826               	.LBE106:
 827 0012 8823      		tst r24
 828 0014 01F4      		brne .L43
 829               	/* epilogue start */
 128:lcd.c         ****   }
 129:lcd.c         **** }
 831               	.LM88:
 832 0016 DF91      		pop r29
 833 0018 CF91      		pop r28
 834 001a 0895      		ret
 839               	.Lscope14:
 841               		.stabd	78,0,0
 842               		.section	.text.lcd_puts_p_fill,"ax",@progbits
 846               	.global	lcd_puts_p_fill
 848               	lcd_puts_p_fill:
 849               		.stabd	46,0,0
 130:lcd.c         **** 
 131:lcd.c         **** void lcd_puts_p_fill(char *s, uint8_t i) {
 851               	.LM89:
 852               	.LFBB15:
 853 0000 1F93      		push r17
 854 0002 CF93      		push r28
 855 0004 DF93      		push r29
 856               	/* prologue: function */
 857               	/* frame size = 0 */
 858 0006 EC01      		movw r28,r24
 859 0008 162F      		mov r17,r22
 860 000a 00C0      		rjmp .L46
 861               	.L47:
 132:lcd.c         ****   char c;
 133:lcd.c         ****   while ((c = pgm_read_byte(s)) != 0) {
 134:lcd.c         ****     lcd_data(c);
 863               	.LM90:
 864 000c 0E94 0000 		call lcd_data
 135:lcd.c         ****     s++;
 866               	.LM91:
 867 0010 2196      		adiw r28,1
 136:lcd.c         ****     i--;
 869               	.LM92:
 870 0012 1150      		subi r17,lo8(-(-1))
 871               	.L46:
 872               	.LBB107:
 134:lcd.c         ****   while ((c = pgm_read_byte(s)) != 0) {
 874               	.LM93:
 875 0014 FE01      		movw r30,r28
 876               	/* #APP */
 877               	 ;  134 "lcd.c" 1
 878 0016 8491      		lpm r24, Z
 879               		
 880               	 ;  0 "" 2
 881               	/* #NOAPP */
 882               	.LBE107:
 883 0018 8823      		tst r24
 884 001a 01F4      		brne .L47
 885 001c 00C0      		rjmp .L51
 886               	.L49:
 137:lcd.c         ****   }
 138:lcd.c         ****   while (i--) {
 139:lcd.c         ****     lcd_data(' ');
 888               	.LM94:
 889 001e 80E2      		ldi r24,lo8(32)
 890 0020 0E94 0000 		call lcd_data
 891 0024 1150      		subi r17,lo8(-(-1))
 892               	.L51:
 139:lcd.c         ****     lcd_data(' ');
 894               	.LM95:
 895 0026 1123      		tst r17
 896 0028 01F4      		brne .L49
 897               	/* epilogue start */
 140:lcd.c         ****   }
 141:lcd.c         **** }
 899               	.LM96:
 900 002a DF91      		pop r29
 901 002c CF91      		pop r28
 902 002e 1F91      		pop r17
 903 0030 0895      		ret
 908               	.Lscope15:
 910               		.stabd	78,0,0
 911               		.section	.text.lcd_clear_line,"ax",@progbits
 913               	.global	lcd_clear_line
 915               	lcd_clear_line:
 916               		.stabd	46,0,0
 142:lcd.c         **** 
 143:lcd.c         **** void lcd_clear_line(void) {
 918               	.LM97:
 919               	.LFBB16:
 920 0000 1F93      		push r17
 921               	/* prologue: function */
 922               	/* frame size = 0 */
 924               	.LM98:
 925 0002 10E0      		ldi r17,lo8(0)
 926               	.L53:
 144:lcd.c         ****   uint8_t i;
 145:lcd.c         ****   for (i = 0; i < 16; i++) {
 146:lcd.c         ****     lcd_data(' ');
 928               	.LM99:
 929 0004 80E2      		ldi r24,lo8(32)
 930 0006 0E94 0000 		call lcd_data
 146:lcd.c         ****     lcd_data(' ');
 932               	.LM100:
 933 000a 1F5F      		subi r17,lo8(-(1))
 934 000c 1031      		cpi r17,lo8(16)
 935 000e 01F4      		brne .L53
 936               	/* epilogue start */
 147:lcd.c         ****   }
 148:lcd.c         **** }
 938               	.LM101:
 939 0010 1F91      		pop r17
 940 0012 0895      		ret
 945               	.Lscope16:
 947               		.stabd	78,0,0
 948               		.section	.text.lcd_line1,"ax",@progbits
 950               	.global	lcd_line1
 952               	lcd_line1:
 953               		.stabd	46,0,0
 149:lcd.c         **** 
 150:lcd.c         **** void lcd_line1(void) {
 955               	.LM102:
 956               	.LFBB17:
 957               	/* prologue: function */
 958               	/* frame size = 0 */
 151:lcd.c         ****   lcd_command(0x80);
 960               	.LM103:
 961 0000 80E8      		ldi r24,lo8(-128)
 962 0002 0E94 0000 		call lcd_command
 963               	/* epilogue start */
 152:lcd.c         ****   //  _delay_ms(1);
 153:lcd.c         **** }
 965               	.LM104:
 966 0006 0895      		ret
 968               	.Lscope17:
 970               		.stabd	78,0,0
 971               		.section	.text.lcd_put,"ax",@progbits
 975               	.global	lcd_put
 977               	lcd_put:
 978               		.stabd	46,0,0
 154:lcd.c         **** 
 155:lcd.c         **** void lcd_put(uint8_t *data, uint8_t cnt) {
 980               	.LM105:
 981               	.LFBB18:
 982 0000 1F93      		push r17
 983 0002 CF93      		push r28
 984 0004 DF93      		push r29
 985               	/* prologue: function */
 986               	/* frame size = 0 */
 987 0006 EC01      		movw r28,r24
 988 0008 162F      		mov r17,r22
 989 000a 00C0      		rjmp .L59
 990               	.L60:
 156:lcd.c         ****   while (cnt--)
 157:lcd.c         ****     lcd_data(*data++);
 992               	.LM106:
 993 000c 8991      		ld r24,Y+
 994 000e 0E94 0000 		call lcd_data
 995 0012 1150      		subi r17,lo8(-(-1))
 996               	.L59:
 157:lcd.c         ****     lcd_data(*data++);
 998               	.LM107:
 999 0014 1123      		tst r17
 1000 0016 01F4      		brne .L60
 1001               	/* epilogue start */
 158:lcd.c         **** }
 1003               	.LM108:
 1004 0018 DF91      		pop r29
 1005 001a CF91      		pop r28
 1006 001c 1F91      		pop r17
 1007 001e 0895      		ret
 1009               	.Lscope18:
 1011               		.stabd	78,0,0
 1012               		.section	.text.lcd_line2,"ax",@progbits
 1014               	.global	lcd_line2
 1016               	lcd_line2:
 1017               		.stabd	46,0,0
 159:lcd.c         **** 
 160:lcd.c         **** void lcd_line2(void) {
 1019               	.LM109:
 1020               	.LFBB19:
 1021               	/* prologue: function */
 1022               	/* frame size = 0 */
 161:lcd.c         ****   lcd_command(0xc0);
 1024               	.LM110:
 1025 0000 80EC      		ldi r24,lo8(-64)
 1026 0002 0E94 0000 		call lcd_command
 1027               	/* epilogue start */
 162:lcd.c         ****   //  _delay_ms(1);
 163:lcd.c         **** }
 1029               	.LM111:
 1030 0006 0895      		ret
 1032               	.Lscope19:
 1034               		.stabd	78,0,0
 1035               		.section	.text.lcd_init,"ax",@progbits
 1037               	.global	lcd_init
 1039               	lcd_init:
 1040               		.stabd	46,0,0
 164:lcd.c         **** 
 165:lcd.c         **** void delay(uint8_t i);
 166:lcd.c         **** void lcd_init(void) {
 1042               	.LM112:
 1043               	.LFBB20:
 1044               	/* prologue: function */
 1045               	/* frame size = 0 */
 167:lcd.c         ****   LCD_DATA_DDR |= 0xF;
 1047               	.LM113:
 1048 0000 8091 6100 		lds r24,97
 1049 0004 8F60      		ori r24,lo8(15)
 1050 0006 8093 6100 		sts 97,r24
 168:lcd.c         ****   LCD_DATA_PORT = 0x00;
 1052               	.LM114:
 1053 000a 1092 6200 		sts 98,__zero_reg__
 169:lcd.c         ****   LCD_CTRL_DDR |= _BV(LCD_RS) | _BV(LCD_ENABLE);
 1055               	.LM115:
 1056 000e 82B1      		in r24,34-32
 1057 0010 8464      		ori r24,lo8(68)
 1058 0012 82B9      		out 34-32,r24
 1059 0014 88EE      		ldi r24,lo8(1000)
 1060 0016 93E0      		ldi r25,hi8(1000)
 1061               	.LBB108:
 1062               	.LBB109:
 1063               	.LBB110:
 1064               	.LBB111:
 1066               	.Ltext5:
 1068               	.LM116:
 1069 0018 20E9      		ldi r18,lo8(400)
 1070 001a 31E0      		ldi r19,hi8(400)
 1071               	.L65:
 1072 001c F901      		movw r30,r18
 1073               	/* #APP */
 1074               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 1075 001e 3197      		1: sbiw r30,1
 1076 0020 01F4      		brne 1b
 1077               	 ;  0 "" 2
 1078               	/* #NOAPP */
 1079               	.LBE111:
 1080               	.LBE110:
 1082               	.Ltext6:
   0:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   1:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   2:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   3:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    All rights reserved.
   4:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
   5:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
   8:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  11:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  14:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      distribution.
  15:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  16:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  18:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  19:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  20:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  32:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* $Id: delay.h,v 1.5.2.1 2009/02/25 10:14:03 joerg_wunsch Exp $ */
  33:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  34:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  35:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  36:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  37:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #include <inttypes.h>
  38:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  39:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  40:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /** \file */
  41:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  42:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \code
  43:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  44:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  45:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  46:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \endcode
  47:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  48:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  49:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  50:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  51:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     used.
  52:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  53:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  54:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  55:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  56:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  57:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  58:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  59:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  60:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  61:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  62:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  63:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  64:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  65:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  66:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  67:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  68:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  69:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     routines linked into the application.
  70:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  71:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  72:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  73:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  74:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  75:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** */
  76:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  78:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  79:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  80:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  81:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  82:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef F_CPU
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  84:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  85:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  86:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  89:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  90:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** #endif
  91:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  92:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** /**
  93:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    \ingroup util_delay
  94:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  95:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
  96:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
  97:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
  98:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
  99:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
 100:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 101:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 
 102:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 103:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 104:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 105:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 106:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 107:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h ****  */
 108:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** void
 109:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 110:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** {
 111:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 112:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	double __tmp = ((F_CPU) / 4e3) * __ms;
 113:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 114:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		__ticks = 1;
 115:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 116:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 	{
 117:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 118:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 119:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		while(__ticks)
 120:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		{
 121:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 122:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 123:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 			__ticks --;
 1084               	.LM117:
 1085 0022 0197      		sbiw r24,1
 120:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay.h **** 		while(__ticks)
 1087               	.LM118:
 1088 0024 01F4      		brne .L65
 1089               	.LBE109:
 1090               	.LBE108:
 1091               	.LBB112:
 1092               	.LBB113:
 1094               	.Ltext7:
  35:lcd.c         ****   uint8_t tmp = SREG;
 1096               	.LM119:
 1097 0026 9FB7      		in r25,__SREG__
  36:lcd.c         ****   cli();
 1099               	.LM120:
 1100               	/* #APP */
 1101               	 ;  36 "lcd.c" 1
 1102 0028 F894      		cli
 1103               	 ;  0 "" 2
  37:lcd.c         ****   LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0xF);
 1105               	.LM121:
 1106               	/* #NOAPP */
 1107 002a 8091 6200 		lds r24,98
 1108 002e 807F      		andi r24,lo8(-16)
 1109 0030 8360      		ori r24,lo8(3)
 1110 0032 8093 6200 		sts 98,r24
 1111               	.LBB114:
 1112               	.LBB115:
  27:lcd.c         ****   LCD_SET_ENABLE();
 1114               	.LM122:
 1115 0036 1E9A      		sbi 35-32,6
  31:lcd.c         ****   LCD_CLEAR_ENABLE();
 1117               	.LM123:
 1118 0038 1E98      		cbi 35-32,6
 1119               	.LBE115:
 1120               	.LBE114:
  39:lcd.c         ****   SREG = tmp;
 1122               	.LM124:
 1123 003a 9FBF      		out __SREG__,r25
 1124               	.LBE113:
 1125               	.LBE112:
 1126               	.LBB116:
 1127               	.LBB117:
  35:lcd.c         ****   uint8_t tmp = SREG;
 1129               	.LM125:
 1130 003c 9FB7      		in r25,__SREG__
  36:lcd.c         ****   cli();
 1132               	.LM126:
 1133               	/* #APP */
 1134               	 ;  36 "lcd.c" 1
 1135 003e F894      		cli
 1136               	 ;  0 "" 2
  37:lcd.c         ****   LCD_DATA_PORT = (LCD_DATA_PORT & 0xF0) | (nibble & 0xF);
 1138               	.LM127:
 1139               	/* #NOAPP */
 1140 0040 8091 6200 		lds r24,98
 1141 0044 807F      		andi r24,lo8(-16)
 1142 0046 8260      		ori r24,lo8(2)
 1143 0048 8093 6200 		sts 98,r24
 1144               	.LBB118:
 1145               	.LBB119:
  27:lcd.c         ****   LCD_SET_ENABLE();
 1147               	.LM128:
 1148 004c 1E9A      		sbi 35-32,6
  31:lcd.c         ****   LCD_CLEAR_ENABLE();
 1150               	.LM129:
 1151 004e 1E98      		cbi 35-32,6
 1152               	.LBE119:
 1153               	.LBE118:
  39:lcd.c         ****   SREG = tmp;
 1155               	.LM130:
 1156 0050 9FBF      		out __SREG__,r25
 1157               	.LBE117:
 1158               	.LBE116:
 1159               	.LBB120:
 1160               	.LBB121:
 1161               	.LBB122:
 1162               	.LBB123:
 1163               	.LBB124:
 1164               	.LBB125:
 1166               	.Ltext8:
 1168               	.LM131:
 1169 0052 80E2      		ldi r24,lo8(800)
 1170 0054 93E0      		ldi r25,hi8(800)
 1171               	/* #APP */
 1172               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 1173 0056 0197      		1: sbiw r24,1
 1174 0058 01F4      		brne 1b
 1175               	 ;  0 "" 2
 1176               	/* #NOAPP */
 1177               	.LBE125:
 1178               	.LBE124:
 1179               	.LBE123:
 1180               	.LBE122:
 1181               	.LBE121:
 1182               	.LBE120:
 1184               	.Ltext9:
 170:lcd.c         **** 
 171:lcd.c         ****   _delay_ms(100);
 172:lcd.c         ****   // wait for display
 173:lcd.c         ****   lcd_putnibble(0x03);
 174:lcd.c         ****   lcd_putnibble(0x02);
 175:lcd.c         ****   _delay_us(200);
 176:lcd.c         ****   lcd_command(0x28); // 8 bit, 2 zeilen
 1186               	.LM132:
 1187 005a 88E2      		ldi r24,lo8(40)
 1188 005c 0E94 0000 		call lcd_command
 1189               	.LBB126:
 1190               	.LBB127:
 1191               	.LBB128:
 1192               	.LBB129:
 1194               	.Ltext10:
  83:/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h **** 	__asm__ volatile (
 1196               	.LM133:
 1197 0060 85E3      		ldi r24,lo8(53)
 1198               	/* #APP */
 1199               	 ;  83 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 1200 0062 8A95      		1: dec r24
 1201 0064 01F4      		brne 1b
 1202               	 ;  0 "" 2
 1203               	/* #NOAPP */
 1204               	.LBE129:
 1205               	.LBE128:
 1206               	.LBE127:
 1207               	.LBE126:
 1209               	.Ltext11:
 177:lcd.c         ****   _delay_us(10);
 178:lcd.c         ****   lcd_command(0xC); // display ein, cursor aus, kein blinken.
 1211               	.LM134:
 1212 0066 8CE0      		ldi r24,lo8(12)
 1213 0068 0E94 0000 		call lcd_command
 179:lcd.c         ****   lcd_command(0x4);
 1215               	.LM135:
 1216 006c 84E0      		ldi r24,lo8(4)
 1217 006e 0E94 0000 		call lcd_command
 180:lcd.c         ****   lcd_command(0x1);
 1219               	.LM136:
 1220 0072 81E0      		ldi r24,lo8(1)
 1221 0074 0E94 0000 		call lcd_command
 181:lcd.c         ****   lcd_command(0x2);
 1223               	.LM137:
 1224 0078 82E0      		ldi r24,lo8(2)
 1225 007a 0E94 0000 		call lcd_command
 1226               	.LBB130:
 1227               	.LBB131:
 1228               	.LBB132:
 1229               	.LBB133:
 1231               	.Ltext12:
 1233               	.LM138:
 1234 007e 80E2      		ldi r24,lo8(20000)
 1235 0080 9EE4      		ldi r25,hi8(20000)
 1236               	/* #APP */
 1237               	 ;  105 "/usr/lib/gcc/avr/4.3.4/../../../avr/include/util/delay_basic.h" 1
 1238 0082 0197      		1: sbiw r24,1
 1239 0084 01F4      		brne 1b
 1240               	 ;  0 "" 2
 1241               	/* epilogue start */
 1242               	/* #NOAPP */
 1243               	.LBE133:
 1244               	.LBE132:
 1245               	.LBE131:
 1246               	.LBE130:
 1248               	.Ltext13:
 182:lcd.c         ****   _delay_ms(5);
 183:lcd.c         **** }
 1250               	.LM139:
 1251 0086 0895      		ret
 1265               	.Lscope20:
 1267               		.stabd	78,0,0
 1268               		.text
 1270               	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 lcd.c
     /tmp/ccbAszaQ.s:2      *ABS*:000000000000003f __SREG__
     /tmp/ccbAszaQ.s:3      *ABS*:000000000000003e __SP_H__
     /tmp/ccbAszaQ.s:4      *ABS*:000000000000003d __SP_L__
     /tmp/ccbAszaQ.s:5      *ABS*:0000000000000034 __CCP__
     /tmp/ccbAszaQ.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccbAszaQ.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccbAszaQ.s:93     .text.lcd_enable:0000000000000000 lcd_enable
     /tmp/ccbAszaQ.s:119    .text.lcd_putnibble:0000000000000000 lcd_putnibble
     /tmp/ccbAszaQ.s:174    .text.lcd_putbyte:0000000000000000 lcd_putbyte
     /tmp/ccbAszaQ.s:268    .text.lcd_command:0000000000000000 lcd_command
     /tmp/ccbAszaQ.s:320    .text.lcd_data:0000000000000000 lcd_data
     /tmp/ccbAszaQ.s:372    .text.lcd_putnumber:0000000000000000 lcd_putnumber
     /tmp/ccbAszaQ.s:419    .text.lcd_putnumber16:0000000000000000 lcd_putnumber16
     /tmp/ccbAszaQ.s:495    .text.lcd_putnumber32:0000000000000000 lcd_putnumber32
     /tmp/ccbAszaQ.s:585    .text.lcd_putcx:0000000000000000 lcd_putcx
     /tmp/ccbAszaQ.s:616    .text.lcd_putnumberx:0000000000000000 lcd_putnumberx
     /tmp/ccbAszaQ.s:649    .text.lcd_putnumberx16:0000000000000000 lcd_putnumberx16
     /tmp/ccbAszaQ.s:700    .text.lcd_puts:0000000000000000 lcd_puts
     /tmp/ccbAszaQ.s:740    .text.lcd_puts_fill:0000000000000000 lcd_puts_fill
     /tmp/ccbAszaQ.s:797    .text.lcd_puts_p:0000000000000000 lcd_puts_p
     /tmp/ccbAszaQ.s:848    .text.lcd_puts_p_fill:0000000000000000 lcd_puts_p_fill
     /tmp/ccbAszaQ.s:915    .text.lcd_clear_line:0000000000000000 lcd_clear_line
     /tmp/ccbAszaQ.s:952    .text.lcd_line1:0000000000000000 lcd_line1
     /tmp/ccbAszaQ.s:977    .text.lcd_put:0000000000000000 lcd_put
     /tmp/ccbAszaQ.s:1016   .text.lcd_line2:0000000000000000 lcd_line2
     /tmp/ccbAszaQ.s:1039   .text.lcd_init:0000000000000000 lcd_init

UNDEFINED SYMBOLS
__do_copy_data
__do_clear_bss
__udivmodqi4
__udivmodhi4
__prologue_saves__
__udivmodsi4
__epilogue_restores__
